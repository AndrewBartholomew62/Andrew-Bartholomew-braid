/**************************************************************************************************************
                         Polynomial template definitions

                  A. Bartholomew  June 2004

 Derived from polynoml.h  A. Bartholomew  25th November, 2001
 Extended to support mapped variables May 2020

Polynomials are defined here to be doubly-linked lists of pterm structures, headed by a polynomial structure 
that points at the start of the list.  Each pterm structure corresponds to one term of the polynomial, with only
non-zero terms being stored, the number of terms currently held is recorded in the length field of the polynomial 
structure that points to this list

The polynomial structure also contains information about the number of variables in the polynomial, and the 
variable characters used.  These definitions do not limit the number of variables, nor the particular choice of 
variable characters, but the characters i,j,k,I,J,K should be avoided since polynomials may involve quaternions.

Polynomials are taken here to be elements of the ring of polynomials generated by the stated variables and their 
inverses.  

The polynomial structure stores the absolute degree of each variable, in the same order as the variable characters 
are stored.  Thus, for the polynomial  x^2y^-3+xy, the absolute degree of x is 2 and that of y is 3.

The zero polynomial is represented by any polynomial structure with a null list pointer.

Unit polynomials have no variables, or degrees.

The pterm structures carry the coefficient and the place in the canonical order to which the pterm corresponds (see 
below). The pterms also contain a pointer to the previous and next pterm in the list: the first pterm in the list will 
contain a NULL previous pointer, and the last a NULL next pointer.

The pterms do not store the variables to which the coefficients apply, instead we store the place the pterm has in 
a virtual array of pterms.  This is list of polynomial terms based on a canonical ordering of the variables and which 
is described below.  Many of these terms will be zero, which is why we store the place in the list; it also provides 
a simple mechanism for determining where in a list a pterm should be stored, which is necessary when we start adding 
or multiplying polynomials.

The canonical order of terms is in increasing order based on the exponent of the variables, which may be either positive 
or negative.  For a single variable polynomial, this order is

	x^0, x^-0, x^1, x^-1... x^n, x^-n,

the reason for the -0 exponent is due to the place calculation described below.  For a two variable polynomial, the order is:

	x^0y^0, x^0y^-0, x^0y^1, x^0y^-1, ...,x^0y^n, x^0y^-n...
	x^-0y^0, x^-0y^-0, x^-0y^1, x^-0y^-1, ...,x^-0y^n, x^-0y^-n...
	...
	x^my^0, x^my^-0, x^my^1, x^my^-1, ...,x^my^n, x^my^-n...
	x^-my^0, x^-my^-0, x^-my^1, x^-my^-1, ...,x^-my^n, x^-my^-n...

We are assuming here that the absolute exponent of x is m and the absolute exponent of y is n.  There are many duplicates in 
such an order, but since we use this ordering only to caculate a place this is does not matter.

A three variable polynomial example will enable us to see how to cacluate places, consider an additional variable z of absolute 
exponent k.

	x^0y^0z^0, x^0y^0z^-0, x^0y^0z^1, x^0y^0z^-1, ...,x^0y^0z^k, x^0y^0z^-k...
	[there are a total of 2(k+1) entries in the list to this point]
	x^0y^-0z^0, x^0y^-0z^-0, x^0y^-0z^1, x^0y^-0z^-1, ...,x^0y^-0z^k, x^0y^-0z^-k...
	...
	x^0y^nz^0, x^0y^nz^-0, x^0y^nz^1, x^0y^nz^-1, ...,x^0y^nz^k, x^0y^nz^-k...
	x^0y^-nz^0, x^0y^-nz^-0, x^0y^-nz^1, x^0y^-nz^-1, ...,x^0y^-nz^k, x^0y^-nz^-k...
	[there are a total of 2(n+1)*2(k+1) entries in the list to this point,
	which we shall refer to as the x^0 block, or block 0]
	...
	[here's the x^-0 block, or block 1]
	x^-0y^0z^0, x^-0y^0z^-0, x^-0y^0z^1, x^-0y^0z^-1, ...,x^-0y^0z^k, x^-0y^0z^-k...
	x^-0y^-0z^0, x^-0y^-0z^-0, x^-0y^-0z^1, x^-0y^-0z^-1, ...,x^-0y^-0z^k, x^-0y^-0z^-k...
	...
	x^-0y^nz^0, x^-0y^nz^-0, x^-0y^nz^1, x^-0y^nz^-1, ...,x^-0y^nz^k, x^-0y^nz^-k...
	x^-0y^-nz^0, x^-0y^-nz^-0, x^-0y^-nz^1, x^-0y^-nz^-1, ...,x^-0y^-nz^k, x^-0y^-nz^-k...
	...
	[ending with the x^m and x^-m block, blocks 2m and 2m+1 ]
	x^my^0z^0, x^my^0z^-0, x^my^0z^1, x^my^0z^-1, ...,x^my^0z^k, x^my^0z^-k...
	x^my^-0z^0, x^my^-0z^-0, x^my^-0z^1, x^my^-0z^-1, ...,x^my^-0z^k, x^my^-0z^-k...
	...
	x^my^nz^0, x^my^nz^-0, x^my^nz^1, x^my^nz^-1, ...,x^my^nz^k, x^my^nz^-k...
	x^my^-nz^0, x^my^-nz^-0, x^my^-nz^1, x^my^-nz^-1, ...,x^my^-nz^k, x^my^-nz^-k
	x^-my^0z^0, x^-my^0z^-0, x^-my^0z^1, x^-my^0z^-1, ...,x^-my^0z^k, x^-my^0z^-k...
	x^-my^-0z^0, x^-my^-0z^-0, x^-my^-0z^1, x^-my^-0z^-1, ...,x^-my^-0z^k, x^-my^-0z^-k...
	...
	x^-my^nz^0, x^-my^nz^-0, x^-my^nz^1, x^-my^nz^-1, ...,x^-my^nz^k, x^-my^nz^-k...
	x^-my^-nz^0, x^-my^-nz^-0, x^-my^-nz^1, x^-my^-nz^-1, ...,x^-my^-nz^k, x^-my^-nz^-k

There are a total of 2(m+1)*2(n+1)*2(k+1) entries in the list altogether.

Given a variable place p, in the range 0,...2(m+1)*2(n+1)*2(k+1), by looking at the integer part of p/(2(n+1)*2(k+1)), 
we can tell which block the variable place lies in, and therfore the power of the variable x.  If the block number is 
odd, the power is a negative one, otherwise a positive one, by dividing the block number by 2 and taking the integral
part we determine the power of x of the variable stored in place p.

We now take the remainder of p/(2(n+1)*2(k+1)), which indicates the offset into the block of place p.  We can now work 
recursively, dividing this offset by 2(k+1) to determine the power of y and then finally the power of z.

To calculate the place corresponding to a particular set of variables, simply work backwards through this calculation.

Thus to cacluate the exponents from a place pl, we have code of the form:

	factor = poly.l;
	place = pl;
	for (i=0; i<poly.nv;i++)
	{
	    factor /= (2*(poly.vd[i]+1));
	    if ((place/factor)%2)
		negative_exp = true;
	    else
		negative_exp = false;
	
	    power = place/factor/2;
	    if (negative_exp)
		power *= -1;
	
	    aexponent[i] = power;
	    place %= factor;
	}

and to calculate a place:

	place = 0;
	factor = l;
	for (i=0; i<poly.nv;i++)
	{
	    factor /= 2 * (poly.vd[i]+1);
	    block_num = 2 * abs(exponent[i]);
	    if (exponent[i] < 0)
		block_num++;
	    place += block_num*factor;
	}
	
Variable mappings, introduced in 2020, allow polynomials involving variables of arbitary type to be handled.  
The motivating cases were the arrow polynomial, which requires variables \Lambda_i and K_i (strings rather than
characters) and the parity bracket polynomial, which includes graphical nodes as variables.  These non-character
variables are mapped to proxy character variables in order that the existing code may be re-used, with the mapped 
type being used for variable comparison and output.
	
The implementation does not require that the character used as a proxy for a mapped variable is always the same. 
Thus, if in x+y the variable x is mapped to an object V and in y+z the variable z is mapped to the same V, then 
these two polynomials are considered to be the same.

When writing a polynomial with mapped variable to an output stream, the control boolean SUBSTITUTE_MAPPED_VARIABLES 
is used to determine whether the proxy characters or the mapped object is displayed.  If the boolean is false, then 
the output of the above polynomial x+y would appear as "x+y (x,V)" to indicate the variable mapping, whilst if the 
boolean is true, the polynomial would appear as "x+V", using the output operator for the object type of V.

At most one variable in a polynomial may be mapped to a given V, an attempt to map a subsequent variable to the same V
replaces the mapping of the existing variable with the new variable.
**************************************************************************************************************/

#include <string>
#include <sstream>
#include <vector>
#include <map>

struct polynomial_control {

	static unsigned int DEBUG; //bitmap
	enum parameters
	{
		general=1, 
		sanitize=2, 
		add=4, 
		multiply=8, 
		divide=16, 
		gcd=32,
		input=64
		// 'all' also supported
	};

	static bool WAIT_INFO;
	static bool MOD_P; // used in the output function to control the generation of '-' signs
	static bool OUTPUT_PROXY_VARIABLES_ONLY;  // used for inverting variables
	static bool SUBSTITUTE_MAPPED_VARIABLES;  // used for polynomial output
	static bool WRITE_PARITY_PEER_CODES; // in addition to unoriented left preferred Gauss code
	static bool TeX; // output polynomials in TeX format.
	static int wait_threshold;
};

template <typename T, typename V, typename U> struct poly_div_res;
template <typename T, typename V, typename U> class polynomial;

template <typename T, typename U>	struct pterm
{
    T 			n;     	/* coefficient */
    U           pl;     /* place in canonical order - counted from zero */
    pterm*      prev;   /* pointer to previous term */
    pterm*      next;   /* pointer to next tern */
	
};


struct polynomial_error {
	polynomial_error (char* message) {cout << "\nPolynomial error! " << message << endl;}
};

template <typename T, typename V, typename U> struct poly_div_res
{
   	polynomial<T,V,U> q;
   	polynomial<T,V,U> r;
};

template <typename K, typename V> typename map<K,V>::const_iterator find_value (const map<K,V>& m, V v)
{
	typename map<K,V>::const_iterator mptr=m.begin();
	while (mptr != m.end())
	{
		if (mptr->second == v)
			break;
		mptr++;
	}
	return mptr;
}

/* First the friend functions */

/* this gcd template is a specialization to handle
	- multivariate polynomials
    - polynomials with differente variables
    - laurent polynomials
   returning 1 in each case.
*/
template <typename T, typename V, typename U> polynomial<T,V,U> gcd (const polynomial<T,V,U>& i,  const polynomial<T,V,U>& j)
{
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: i = " << i << " j = " << j << endl;
	if ( i.nv > 1 || j.nv > 1 || (i.nv && j.nv && strcmp(i.vc,j.vc))  || i.laurent() || j.laurent() )
	{
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: returning 1" << endl;
		return polynomial<T,V,U>(T(1));
	}
	else
	{

	    if (i.nonzero())
			if (j.nonzero())
			{
//				if (i/j == T(0) && j/i == T(0)) // the i%j = i and j%i = j loop
				if ((i/j).iszero() && (j/i).iszero()) // the i%j = i and j%i = j loop
				{
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: remainder loop detected, returning 1" << endl;
					return polynomial<T,V,U>(T(1));
				}
				
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: recursing with " << j << " and " << i%j << endl;
		    	return ( gcd<T,V,U>(j, i%j));
			}
			else
			{
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: returning " << i << endl;
			    return (i);
			}
	    else
		{
if (polynomial_control::DEBUG & polynomial_control::gcd)
	debug << "polynomial<T,V,U>::gcd: returning " << j << endl;
			return (j);
		}
	}
}

template <typename T, typename V, typename U> ostream& operator << (ostream& os, const polynomial<T,V,U>& poly)
{
    char        v;
    int         i;
    U factor;
    U place;
    int power;
    bool negative;
    bool first_term = true;

    pterm<T,U>* pterm_ptr;
	
    /* set the width of the outstream back to 0 */
    os.width(0);

    /* check for the zero polynomial */
    if (poly.p == 0)
    {
        os << '0';

        return os;
    }

    pterm_ptr = poly.p;
    while (pterm_ptr->next)
        pterm_ptr = pterm_ptr->next;

    /* now at then end of the list, output and move backwards */
    do
    {
        /* put out the coefficient.  If this is not the unit term
           and the absolute value of the coefficient is 1 we may
           dispense with the coefficient.  Note that we cannot really talk 
		   of absolute value here, since we may have T=quaternion<X> for 
		   some X and the absolute value of a quaternion is its modulus.
		   Therefore we have to check that the coefficient is neither 1 or -1.
		   
		   We have to pay particular attention to the situation where we are working 
		   mod p.  Here the value -1 is written p-1 and we *do* need to write the
		   coefficient, provided p != 2 when p-1=1.  Thus, we write the coefficient if
		   
		  a) The place is non-zero (not the unit term)
		  b) We're working mod p and the coefficient is -1 (but not also == 1, which is the p=2 case)
		  c) We're not working mod p and the coefficient is not 1 or -1.
		  
        */

        if (!first_term && T(pterm_ptr->n) > T(0))
            os << '+';
        else if (!polynomial_control::MOD_P && pterm_ptr->pl && pterm_ptr->n == T(-1))
           os << '-';

        if (!pterm_ptr->pl ||
		    (polynomial_control::MOD_P && pterm_ptr->n == T(-1) && pterm_ptr->n != T(1)) || 
			(pterm_ptr->n != T(1) && pterm_ptr->n != T(-1))
		   ) 
		{
            os << pterm_ptr->n;
		}
			
        /* now the variables */
        factor = poly.l;
        place = pterm_ptr->pl;
        for (i=0; i<poly.nv;i++)
        {
            factor /= (2*(poly.vd[i]+1));
            if ((place/factor)%U(2))
                negative = true;
            else
                negative = false;

            power = place/factor/U(2);
            if (negative)
                power *= -1;

            if (power)
            {
                v = poly.vc[i];
				
				if (poly.vm.count(v) && polynomial_control::SUBSTITUTE_MAPPED_VARIABLES && !polynomial_control::OUTPUT_PROXY_VARIABLES_ONLY)
					os << poly.get_varmap(v);
				else
					os << v;

                if (power != 1)
                {
					if (polynomial_control::TeX)
						os << "^{";
					else
						os << '^';
					
                    os << power;
                    
					if (polynomial_control::TeX)
						os << '}';
                }
            }

            place %= factor;
        }

        /* step back one term */
        pterm_ptr = pterm_ptr->prev;
        first_term = false;
    } while (pterm_ptr);


	if (!polynomial_control::SUBSTITUTE_MAPPED_VARIABLES && poly.vm.size() && !polynomial_control::OUTPUT_PROXY_VARIABLES_ONLY)
	{
//		os << " #";
		os << " : ";
		typename map<char,V>::const_iterator mptr = poly.vm.begin();
		while (mptr != poly.vm.end())
		{
//			os << '(' << mptr->first << ',' << mptr->second << ") ";
			os << mptr->first << '=' << mptr->second << " ";
			mptr++;
		}
	}

    return os;
}

template <typename T, typename V, typename U> istream& operator >> (istream& s, polynomial<T,V,U>& p)
{
	polynomial<T,V,U>	poly;

	string inbuf;
	s >> inbuf;

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: presented with string: " << inbuf << endl;

    if (inbuf == "0")
    {
        /* set poly_ptr to zero polynomial */
		poly = polynomial<T,V,U>(T(0)); //construct a T from the int and assign to poly

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: setting zero polynomial" << endl;

    }
    else if (inbuf == "1")
    {
        /* set poly_ptr to a polynomial with one term*/
		poly = polynomial<T,V,U>(T(1));

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: setting polynomial to 1" << endl;

    }
    else
    {
        /* 
		   First, we check whether the polynomial is enclosed in parentheses and 
		   remove them if it is.
        */
		
		char* c_inbuf = c_string(inbuf);
    	char* cptr = c_inbuf;
			
		if (*cptr == '(')
		{

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: polynomial begins with '(', checking for parentheses" << endl;

			/* parentheses are detected by an open bracket by the time
			   we reach the first alpha: ((...)x...
			*/
			int count = 1;
			do
			{
				cptr++;
				if (*cptr == '(')
					count++;
				else if (*cptr == ')')
					count--;
			} while (!isalpha(*cptr));
			
			if (count)
			{
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: open parentheses detected" << endl;
				/* remove the parentheses from c_inbuf */
				strcpy(c_inbuf,&c_inbuf[1]);
				if (c_inbuf[strlen(c_inbuf)-1] != ')')
				{
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: no matching ')', for opening parenthesis, ignoring and continuing to read polynomial" << endl;
				}
				else
				{
					/* check that the terminating ')' is not the end of a quaternion
					   we use the same technique as above, but working from the end 
					   of the string looking for an alpha.  We expect z^2+(1,1,1,1))
					   or similar, so can apply the same logic as before.  Note that this
					   approach does not support the degenerate case where the polynomial is actually 
					   a single coefficient (4), or (3/4) or ((1,1,1,1))
					*/
					cptr = &c_inbuf[strlen(c_inbuf)-1];
					int count = 1;
					do
					{
						cptr--;
						if (*cptr == ')')
							count++;
						else if (*cptr == '(')
							count--;
					} while (!isalpha(*cptr));
			
					if (count)
					{				
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: close parentheses detected" << endl;
						c_inbuf[strlen(c_inbuf)-1] = '\0';
					}
					else
					{
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: closing ')', does not match opening parenthesis, continuing to read polynomial" << endl;
					}
				}
				
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: input buffer after removal of parentheses: " << c_inbuf << endl;
				
			}
		}
		
		
		/* scan the input to evaluate the number of terms in the polynomial by 
		   looking for + and - signs; at the same time, determine the number of 
		   variables and the variable characters.  
		*/		
		poly.nv = 0;
		string variables;
    	int num_terms = 1;
    	bool term_level = true;
    	cptr = c_inbuf;
		do
		{
	    	/* if cptr is an alpha it points at a variable of this
		       polynomial; if so, add it to the vc list if its not already
		       there
		    */
		    if (isalpha(*cptr) && variables.find(*cptr) == string::npos)
	    	{
				poly.nv++;
				variables += *cptr;
	    	}
	    	else if (*cptr == '(')
				term_level = false; /* entering a quaternion */
	    	else if (*cptr == ')')
				term_level = true; /* leaving a quaternion */
	    	else if (cptr != c_inbuf && term_level &&
			  	(*cptr == '+' || *cptr == '-') && *(cptr-1) != '^')
				num_terms++;
		} while (*++cptr != '\0');

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: number of variables = " << poly.nv << endl;

        /* sort the polynomial variables */
		if (poly.nv)
		{
			sort(variables.begin(), variables.end());
			poly.vc = new char[variables.length()+1];
			poly.vc[variables.copy(poly.vc,string::npos)] = 0;

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: variable characters: " << variables << endl;
			
		}
		else
		{
	    	poly.vc = NULL;
		}

        /* determine the degree of the polynomial in each variable */
		if (poly.nv)
			poly.vd = new int[poly.nv];
		else 
	    	poly.vd = NULL;

        cptr = c_inbuf;
		for (int i=0;i<poly.nv; i++)
		    poly.vd[i] = 0;
		do
		{
		    int degree=0;
					
	    	if (isalpha(*cptr))
	    	{
				char* mark = cptr+2;

                if(*(cptr+1) != '^')
                    degree = 1;
                else
                {
                    cptr = mark+1;
                    while (isdigit(*cptr))
                        cptr++;
                    get_number(degree,mark);
                    cptr--;
                }
				int index = strchr(poly.vc, *(mark-2)) - poly.vc;
				if (abs(degree) > poly.vd[index])
		    		poly.vd[index] = abs(degree);
	    	}
		} while (*++cptr != '\0');

if (polynomial_control::DEBUG & polynomial_control::input)
{
	debug << "polynomial<T,V,U>::>>: variable degrees: ";
	for (int i=0;i<poly.nv; i++)
	    debug << poly.vd[i] << ' ';
	debug << endl;
}

        /* now determine the maximum number of virtual pterms
           this polynomial requires */
		poly.l = 1;

		for (int i=0; i<poly.nv; i++)
			poly.l *= 2 * (poly.vd[i] + 1);

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: length of virtual pterm list = " << poly.l << endl;

        /* now assign the pterms, we create a new pterm, then add
           it to the polynomial, first set the polynomial pterm pointer
           to NULL.
        */
		poly.p = NULL;

        /* we need an array to store the exponents
           of the variables in each term
        */
		int exponent[poly.nv];


		/* set inbuf to the current value of c_inbuf, which may have had parentheses
		   removed, before creating an istringstream for reading the polynomial */
		inbuf = string(c_inbuf);   
		istringstream iss(inbuf);

        for (int i = 0; i< num_terms; i++)
        {
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: reading term " << i+1 << ": " << endl;
	        pterm<T,U>* new_pterm = new pterm<T,U>;
            new_pterm->next = NULL;
            new_pterm->prev = NULL;

			/* input the coefficient, start by looking for a sign:
			   we have to deal with the cases -x -2x+2 x-2y x-y x+y
			   and the >> operator fails to read -1 in the case -x
			   so we handle the sign explicitly
			*/
			char c;
			int sign;
			
			iss >> c;

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   initial character read from istream = " << c << endl;
			
			if (c == '-')
			{
				sign = -1;
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   explicit sign = " << sign << endl;
			}
			else if (c == '+')
			{
				sign = 1;
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   explicit sign = " << sign << endl;
			}
			else
			{
				sign = 1;
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   implicit sign = " << sign << endl;
				iss.putback(c);  // this should only be the first term with no leading sign
			}
				
			
			iss >> new_pterm->n;
			if (iss.fail())
			{
				new_pterm->n = T(1);

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   implicit absolute coefficient = 1" << endl;
	
				iss.clear();

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   clearing state flags on istream at " << &iss << endl;
			}
			else
			{
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   absolute coefficient = " << new_pterm->n << endl;
			}
			
			new_pterm->n *= T(sign);
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   coefficient value = " << new_pterm->n << endl;
			
			/* read the variables and their powers */
	    	for (int j=0; j < poly.nv;j++)
				exponent[j] = 0;

			do
			{
				iss >> c;
				if (iss.fail()) // the last term may have no variable
				{
					break;
				}
				else
				{
					if (isalpha(c))
					{
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   read variable " << c << endl;
						int index = strchr(poly.vc, c) - poly.vc;
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   index = " << index << endl;
						char carrat = 0;
						iss >> carrat;
						if (carrat == '^')
						{
						iss >> exponent[index];
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   read exponent = " << exponent[index] << endl;
						}
						else // includes case where the input to carrat fails due to the polynomial ending in a variable: e.g x^2+x
						{
							exponent[index] = 1;  
							iss.putback(carrat);
if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>:   set exponent = 1" << endl;
						}
					}
					else if (c == '+' || c == '-')
					{
						iss.putback(c);
						break;
					}
				}
			} while (true);
			
            /* exponent now indicates the exponents of the variables
		       in the same order as they are given in poly.vc,
		       we now determine the place in the virtual pterm[]
		       corresponding to this term
            */
            U place = 0;
	    	U factor = poly.l;
	    	for (int j=0; j<poly.nv;j++)
	    	{
				factor /= 2 * (poly.vd[j]+1);
				U block_num = 2 * abs(exponent[j]);
				if (exponent[j] < 0)
		    		block_num++;
				place += block_num*factor;
	    	}

            new_pterm->pl = place;

if (polynomial_control::DEBUG & polynomial_control::input)
	debug << "polynomial<T,V,U>::>>: term place = " << place << endl;

            /* Now add the pterm to the polynomial */
	    	polynomial<T,V,U>::add_pterm(poly,new_pterm);
		}

		delete [] c_inbuf;
    }
	
	p = poly;


if (polynomial_control::DEBUG & polynomial_control::input)
{
	debug << "polynomial<T,V,U>::>>: final polynomial value: " << poly << endl;
	debug << "polynomial<T,V,U>::>>: final polynomial structure: " << endl;
	dump(debug,poly);
}
	return s;
}


template<typename T, typename V, typename U> inline polynomial<T,V,U> operator + (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
    polynomial<T,V,U> result = a;
    return result += b;
}

template<typename T, typename V, typename U> inline polynomial<T,V,U> operator - (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
    polynomial<T,V,U> result = a;
    return result -= b;
}

template<typename T, typename V, typename U> inline polynomial<T,V,U> operator * (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
    polynomial<T,V,U> result = a;
    return result *= b;
}

template<typename T, typename V, typename U> inline polynomial<T,V,U> operator / (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
    polynomial<T,V,U> result = a;
    return result /= b;
}

template<typename T, typename V, typename U> inline polynomial<T,V,U> operator % (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
    polynomial<T,V,U> result = a;
    return result %= b;
}

template <typename T, typename V, typename U> inline bool operator != (const polynomial<T,V,U>& a, const polynomial<T,V,U>& b)
{
	return !(a==b);
}

/* this division function is designed for normal polynomials not for Laurent
   polynomials, though it uses the same virtual pterm array so we keep the
   place and evaluation code the same.  The operator returns an array of two
   polynomial pointers, the quotient and remainder, in that order,
   when numerator is divided by denominator; it does not affect either
   parameter.
   
   The call by value allows us to manipulate the variables, to align any variable maping

   If the operator discovers an error, such as division by zero,
   the quotient pointer is NULL.
*/
template <typename T, typename V, typename U> poly_div_res<T,V,U> divide_by (polynomial<T,V,U> numerator, polynomial<T,V,U> denominator)
{
    int			i;
    U			factor;
    U			place;
    int			power;
    int			index;
    U			block_num;
    int*		n_exponent;
    int*		d_exponent;
    char*		cptr;
    bool		variables_ok;
    bool		degrees_ok;
    bool		division_possible;
    bool		negative_exp;
    poly_div_res<T,V,U>	result;
    polynomial<T,V,U>	product;
    pterm<T,U>*		pterm_ptr;
    polynomial<T,V,U>		quot_term;
    pterm<T,U>*		npterm;
    pterm<T,U>*		dpterm;

	
if (polynomial_control::DEBUG & polynomial_control::divide)
{
    debug << "polynomial::divide_by: numerator = " << numerator << endl;
    debug << "polynomial::divide_by: denominator = " << denominator << endl;
}

    if (!denominator.p)
    {
		/* division by zero return error
		*/
		cout << "\n\nError! Polynomial division by zero";
		exit(0);
    }

    if (!numerator.p)
    {
		/* return the zero polynomial */
		result.q = polynomial<T,V,U>(T(0));
		result.r = polynomial<T,V,U>(T(0));
		return result;
    }

    /* compare variables, the variables in the denominator must be contained
       in the numerator if a quotient is to exist.  We use merge_variables to 
	   align the variables of the denominator to the numerator, in case we have
	   mapped variables
    */
    variables_ok = true;
	
    if (denominator.nv > numerator.nv)
		variables_ok = false;
    else
    {
		merge_variables(numerator,denominator);
		for (i=0; i< denominator.nv; i++)
		{
	    	if (!strchr(numerator.vc, denominator.vc[i]))
	    	{
				variables_ok = false;
if (polynomial_control::DEBUG & polynomial_control::divide)
	debug << "polynomial::divide_by: variables not suitable for division" << endl;
				break;
	    	}
		}
    }

    /* further, the degrees of the numerator variables must be >= than the
       degrees of the denominator variables for a quotient to exist, as
       we are not considering Laurent polynomials here.
    */
    degrees_ok = true;
    if (variables_ok)
    {
		for (i = 0; i<denominator.nv; i++)
		{
		    cptr = strchr(numerator.vc, denominator.vc[i]);
	    	/* cptr points to the position in the numerator of the
		       ith variable in the denominator - these are not necessarily
		       in the same place.
		    */
	    	if (denominator.vd[i] > numerator.vd[cptr-numerator.vc])
	    	{
				degrees_ok = false;
if (polynomial_control::DEBUG & polynomial_control::divide)
	debug << "polynomial::divide_by: degress not suitable for division" << endl;
				break;
	    	}
		}
    }

    /* If the denominator contains a variable not present in the
       numerator, or the degree of a denominator variable exceeds
       the degree of that variable in the numerator, then the quotient
       is zero and the remainder is equal to the numerator
    */
    if ( !variables_ok || !degrees_ok )
    {
		result.q = polynomial<T,V,U>(T(0));
		result.r = numerator;
		return result;
    }

    /* so, here a quotient really does exist */

    /* we take the variables of the quotient to be those of the
       numerator, we can tidy up later.
    */
    result.q.nv = numerator.nv;
    if (result.q.nv)
    {
		result.q.vc = new char[numerator.nv+1];
		strcpy (result.q.vc,numerator.vc);
    }
    else
		result.q.vc = NULL;

	/* initialize the degrees for the quotient to be those of the
	   numerator, we will tidy up later.
	*/
    if (result.q.nv)
    {
		result.q.vd = new int[result.q.nv];
		
		for (i=0; i < result.q.nv; i++)
			result.q.vd[i] = numerator.vd[i];
	}
    else
		result.q.vd = NULL;

	/* now the length */
    result.q.l = 1;
    for (i=0; i< result.q.nv; i++)
		result.q.l *= 2*(result.q.vd[i] + 1);
		
	/* and the variable map */
	if (numerator.vm.size())
		result.q.vm = numerator.vm;


    /* form the quotient, we make a working copy of the numerator */
    polynomial<T,V,U> num = numerator;

    /* assign space for the exponent records, these are always maintained
       in terms of the variables in numerator
    */
    n_exponent = new int[numerator.nv];
    d_exponent = new int[numerator.nv];

    for (i=0; i< numerator.nv; i++)
		d_exponent[i] = 0;

    /* the denominator term with the highest degree is
       at the end of the pterm list.
    */
    dpterm = denominator.p;
    while ( dpterm->next )
		dpterm = dpterm->next;

    /* determine the exponent values of this place.  We calculate
       the exponent from the denominator variables then check to
       see where in d_exponent they should be stored.
    */
    factor = denominator.l;
    place = dpterm->pl;
    for (i=0; i<denominator.nv;i++)
    {
		factor /= (2*(denominator.vd[i]+1));
		if ((place/factor)%U(2))
		    negative_exp = true;
		else
	    	negative_exp = false;

		power = place/factor/U(2);
		if (negative_exp)
		    power *= -1;

		index = strchr(numerator.vc, denominator.vc[i]) - numerator.vc;
		d_exponent[index] = power;

		place %= factor;
    }

    /* Next, prepare quot_term to accept the terms of the quotient.
       We use the variable degrees and length from result, as quot_term
       will be used to hold (temporarily) pterms belonging to the quotient.
    */
    quot_term.nv = numerator.nv;
    if (quot_term.nv)
    {
		quot_term.vc = new char[numerator.nv+1];
		strcpy(quot_term.vc,numerator.vc);
		quot_term.vd = new int[numerator.nv];
		for (i=0; i<numerator.nv; i++)
		    quot_term.vd[i] = (result.q.vd)[i];
    }
    else
    {
		quot_term.vc = NULL;
		quot_term.vd = NULL;
    }
    
    if (numerator.vm.size())
		quot_term.vm = numerator.vm;

    quot_term.l = result.q.l;

    /* now start the division */
    while ( num.p )
    {
		/* evaluate the next quotient term, if it exists. */
		division_possible = true;

		/* During the course of the enclosing loop num may be sanitized
		   so that there is a variable in the denominator that does not
		   appear in num any longer.
		*/
		if (denominator.nv > num.nv)
	    	division_possible = false;
		else
		{
		    for (i=0; i< denominator.nv; i++)
	    	{
				if (!strchr(num.vc, denominator.vc[i]))
				{
		    		division_possible = false;
if (polynomial_control::DEBUG & polynomial_control::divide)
	debug << "polynomial::divide_by: numerator now contains variables not suitable for division" << endl;
		    		break;
				}
	    	}
		}

		if (!division_possible)
		    break;

		/* the term in the numerator with the highest degree
		   is at the end of the pterm list
		*/
		npterm = num.p;
		while (npterm->next)
		    npterm = npterm->next;

		/* determine the exponent values of this place - note that
		   n_exponent holds exponents in terms of the variables in
		   numerator, which is not necessarily the same as those
		   left in num.
		*/
		for (i=0; i<numerator.nv;i++)
	    	n_exponent[i] = 0;

		factor = num.l;
		place = npterm->pl;
		for (i=0; i<num.nv;i++)
		{
		    factor /= (2*(num.vd[i]+1));
	    	if ((place/factor)%U(2))
				negative_exp = true;
	    	else
				negative_exp = false;

	    	power = place/factor/U(2);
	    	if (negative_exp)
				power *= -1;

	    	index = strchr(numerator.vc, num.vc[i]) - numerator.vc;
	    	n_exponent[index] = power;

	    	place %= factor;
		}

		/* The new term, if it exists, has exponents equal to the difference
		   between the n_exponent and d_exponent values, we store this
		   difference in n_exponent.  If a d_exponent value is greater then the
		   corresponding n_exponent value, the division is not possible.
		*/
		for (i=0; i<numerator.nv; i++)
		{
		    n_exponent[i] -= d_exponent[i];
	    	if (n_exponent[i] < 0)
	    	{
				division_possible = false;
if (polynomial_control::DEBUG & polynomial_control::divide)
	debug << "polynomial::divide_by: degrees not suitable to create quotient term" << endl;
				break;
		    }
		}

		if (!division_possible)
		    break; /* jump out asap */

		/* We'll use the exponents just calculated to determin the place
		   for the next quotient term in the result, but first we
		   determine the coefficient of this next quotient term.
		*/

	    if (npterm->n % dpterm->n != T(0))
    	{
			/* the [USED TO SAY integer] coefficients do not divide - break out */
			break;
    	}
    	else
    	{
			quot_term.p = new pterm<T,U>;
			pterm_ptr = quot_term.p;
			pterm_ptr->n = npterm->n / dpterm->n;
			pterm_ptr->next = NULL;
			pterm_ptr->prev = NULL;
    	}

		/* now determine the place in result.q for the new pterm,
		   recall that quotient uses the variables of numerator
		*/
		place = 0;
		factor = result.q.l;
		for (i=0; i<result.q.nv;i++)
		{
	    	factor /= 2 * (result.q.vd[i]+1);
	    	block_num = 2 * abs(n_exponent[i]);
	    	if (n_exponent[i] < 0)
				block_num++;
	    	place += block_num*factor;
		}
		pterm_ptr->pl = place;

if (polynomial_control::DEBUG & polynomial_control::divide)
    debug << "polynomial::divide_by: quotient term = " << quot_term << endl;

		/* evaluate the product of quot_term and denominator (note that
		   this is non-destructive, so we'll still have the new pterm
		   at pterm_ptr) then subtract the product of the quotient term
		   and the denominator from the numerator.
		*/

		product = quot_term * denominator;

if (polynomial_control::DEBUG & polynomial_control::divide)
    debug << "polynomial::divide_by: product = " << product << endl;

		product *= polynomial<T,V,U>(T(-1));
		num += product;

if(polynomial_control::DEBUG & polynomial_control::divide)
    debug << "polynomial::divide_by: new numerator = " << num << endl;

		/* finally take the new pterm (currently attached to quat_term)
		   and add it to the quotient, then set quot_term.p
		   to be NULL ready for the next term.
		*/
		polynomial<T,V,U>::add_pterm(result.q, pterm_ptr);
		quot_term.p = NULL;
    }

    /* if we have broken out of the above loop,
       there is a non zero remainder, equal to num.
    */
    if (num.p)
    {
		result.r = num;
	    sanitize(&result.r);
    }
    else
    {
		/* remainder is zero */
		result.r = polynomial<T,V,U>(T(0));
    }
	
	sanitize(&result.q);
	sanitize(&result.r);

    delete[] n_exponent;
    delete[] d_exponent;

if (polynomial_control::DEBUG & polynomial_control::divide)
{
	debug << "polynomial::divide_by: result: " << endl;
	debug << "polynomial::divide_by:   numerator = " << numerator << endl;
	debug << "polynomial::divide_by:   denominator = " << denominator << endl;
	debug << "polynomial::divide_by:   quotient = " << result.q << endl;
	debug << "polynomial::divide_by:   remainder = " << result.r << endl;
}
    return result;
}

/* dump will be used for debugging */
template <typename T, typename V, typename U> void dump (ostream& s, const polynomial<T,V,U>& poly,string prefix="")
{
    int i;
    int term = 1;
    U place;
    int power;
    U factor;
    bool negative_exp;
    pterm<T,U>* pterm_ptr;

    s << "\n" << prefix << "polynomial located at    " << &poly;
    s << "\n" << prefix << "number of variables      = " << poly.nv;
    s << "\n" << prefix << "variable characters      = " << (poly.nv? poly.vc : "None");
    s << "\n" << prefix << "variable degrees         = ";
    if (poly.nv)
    {
		for (i=0; i< poly.nv; i++)
		    s << poly.vd[i] << " ";
    }
    else
		s << "Empty";

    s << "\n" << prefix << "variable mapping         = ";
	if (poly.vm.size())
	{
		s << "size = " << poly.vm.size() << ": ";
		typename map<char,V>::const_iterator mptr = poly.vm.begin();
		while (mptr != poly.vm.end())
		{
			s << '(' << mptr->first << ',' << mptr->second << ") ";
			mptr++;
		}
	}
	else
	{
		s << "Empty";
	}
	
    s << "\n" << prefix << "number of virtual pterms = " << poly.l;
    s << "\n" << prefix << "polynomial pterms:";

    if (poly.p)
    {
		int count = 0;
		pterm_ptr = poly.p;
		while (pterm_ptr)
		{
			count++;
			pterm_ptr = pterm_ptr->next;
		}
		s << "       " << count << " present";
        pterm_ptr = poly.p;
        do
        {
            /* work out variables */
            s << "\n" << prefix << term++ << " " << pterm_ptr << ": ";
            factor = poly.l;
            place = pterm_ptr->pl;

            for (i=0; i<poly.nv;i++)
            {
                factor /= (2*(poly.vd[i]+1));
                if ((place/factor)%U(2))
                    negative_exp = true;
                else
                    negative_exp = false;

                power = place/factor/U(2);
                if (negative_exp)
                    power *= -1;

                s << poly.vc[i];
                s << '^';
                s << power;

                place %= factor;
            }

            s << "\n" << prefix << "pterm.n = " << pterm_ptr->n;
            s << "\n" << prefix << "pterm.pl = " << pterm_ptr->pl;
            s << "\t" << "pterm.prev = ";
            if (pterm_ptr->prev)
                s << pterm_ptr->prev;
            else
                s << "NULL";
            s << "\t" << "pterm.next = ";
            if (pterm_ptr->next)
                s << pterm_ptr->next;
            else
                s << "NULL";

            pterm_ptr = pterm_ptr->next;

        } while (pterm_ptr);
    }
    else
	s << "       None, zero polynomial";
    s << endl;
}

template <typename T, typename V, typename U> void sanitize (polynomial<T,V,U>* poly_ptr)
{
    char* new_vc = NULL;
    int i;
    int power;
	U block_num;
	U factor;
	U place;
    int index;
    U new_l;
    int* exponent;
    int* var_flag;
    int* new_vd;
    bool no_change = true;
    bool negative_exp;
    pterm<T,U>* pterm_ptr;
    pterm<T,U>* check_ptr;

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize: sanitizing " << *poly_ptr;
    dump(debug,*poly_ptr,"polynomial::sanitize:   ");
}

	/* start by removing any zero pterms */
    if (poly_ptr->p)
    {
		pterm_ptr = poly_ptr->p;
		while (pterm_ptr->next)
		    pterm_ptr = pterm_ptr->next;

		/* pterm_ptr now indicates the last pterm structure */
		do
		{
	    	/* we may discard pterm_ptr in this iteration of the loop,
		       so record the previous pterm ready for the loop check
		    */
	    	check_ptr = pterm_ptr->prev;

	    	if (pterm_ptr->n == T(0))
	    	{
				/* take out this pterm */
				if (pterm_ptr->prev)
				{
		    		pterm_ptr->prev->next = pterm_ptr->next;
		    		if (pterm_ptr->next)
						pterm_ptr->next->prev = pterm_ptr->prev;
				}
				else
				{
		    		poly_ptr->p = pterm_ptr->next;
		    		if (pterm_ptr->next)
						pterm_ptr->next->prev = NULL;
				}
				delete pterm_ptr;
	    	}
	    	pterm_ptr = check_ptr;
		} while (pterm_ptr);
    }

    if (poly_ptr->p == NULL)
    {
		/* this is the zero polynomial */
		poly_ptr->nv = 0;
		if (poly_ptr->vc)
		    delete[] (poly_ptr->vc);
		poly_ptr->vc = NULL;
		if (poly_ptr->vd)
	    	delete[] (poly_ptr->vd);
		poly_ptr->vd = NULL;
		poly_ptr->l = 0;
		if (poly_ptr->vm.size())
			poly_ptr->vm.clear();
    }
    else if (poly_ptr->nv == 0)
    {
		/* just check for an illegal list and tidy up the
		   header as necessary
		*/
		if (poly_ptr->p->next != NULL || poly_ptr->p->pl != U(0))
		{
	    	cout << "\npolynomial::sanitize: ERROR illegal polynomial structure encountered!";
	    	exit(0);
		}
		else
		{
		    if (poly_ptr->vc)
	    	{
				delete[] (poly_ptr->vc);
				poly_ptr->vc = NULL;
	    	}
	    	if (poly_ptr->vd)
	    	{
				delete[] (poly_ptr->vd);
				poly_ptr->vd = NULL;
	    	}
			if (poly_ptr->vm.size())
				poly_ptr->vm.clear();
	    	poly_ptr->l = 1;
		}
    }
    else
    {
		/* work out the actual maximum exponents in new_vd */

		new_vd = new int[poly_ptr->nv];
		for (i=0; i<poly_ptr->nv; i++)
	    	new_vd[i] = 0;

		/* we know there is at least one pterm */
		pterm_ptr = poly_ptr->p;

		do
		{
		    factor = poly_ptr->l;
	    	place = pterm_ptr->pl;
	    	for (i=0; i<poly_ptr->nv;i++)
	    	{
				factor /= (2*(poly_ptr->vd[i]+1));
				if ((place/factor)%U(2))
		    		negative_exp = true;
				else
		    		negative_exp = false;

				power = place/factor/U(2);
				if (negative_exp)
		    		power *= -1;

				if (abs(power) > new_vd[i])
		    		new_vd[i] = abs(power);

				place %= factor;
	    	}

	    	pterm_ptr = pterm_ptr->next;
		} while (pterm_ptr);

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize: new variable degrees = ";
    for(i=0; i<poly_ptr->nv;i++)
		debug << new_vd[i] << " ";
	debug << endl;
}
		/* if the new variable degrees are all the same as the original ones
		   there is nothing to do, so get out now. */
		for (i=0; i<poly_ptr->nv; i++)
		    if (new_vd[i] < poly_ptr->vd[i])
				no_change = false;

		if (no_change)
		    delete[] new_vd;
		else
		{
	    	/*  assign and initialize exponent and var_flag */
	    	var_flag = new int[poly_ptr->nv];
	    	exponent = new int[poly_ptr->nv];
	    	for (i=0; i<poly_ptr->nv; i++)
				exponent[i] = var_flag[i] = 0;

	    	/* only those variable characters that have non zero
		       exponents as recorded in new_vd are required
	    	*/
	    	new_l = 1;

			string variables;
			
	    	for (i=0; i<poly_ptr->nv; i++)
	    	{
				/* if new_vd[i] is zero, we don't need this variable
				   set var_flag[i] to 1 as a flag is we have kept the
				   variable, leave it as zero if we remove it.
				*/
				if (new_vd[i])
				{
					variables += poly_ptr->vc[i];
		    		new_l *= 2 * (new_vd[i] +1);
		    		var_flag[i] = 1;
				}
				else
				{
					/* remove the variable map for vc[i], if one exists */
					if (poly_ptr->vm.count(poly_ptr->vc[i]))
						poly_ptr->vm.erase(poly_ptr->vc[i]);
				}
				
		    }
			new_vc = new char[variables.length()+1];
			new_vc[variables.copy(new_vc,string::npos)] = 0;

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize: new variables = " << new_vc << endl;
}

	    	/* rearrange new_vd if we have lost one or more variables
		       so that the degrees of the remaining variables are stored
		       in their correct places; i.e. flushed left.
		    */
	    	if (poly_ptr->nv && static_cast<int>(strlen(new_vc)) < poly_ptr->nv)
	    	{
				index = 0;
				for (i=0; i<poly_ptr->nv;i++)
				{
				    if (new_vd[i])
						new_vd[index++] = new_vd[i];
				}
	    	}
if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize: rearranged new variable degrees = ";
    for(i=0; i<poly_ptr->nv;i++)
	debug << new_vd[i] << " ";
	debug << endl;
}

	    	pterm_ptr = poly_ptr->p;
	    	do
	    	{
				for (i=0; i<poly_ptr->nv; i++)
		    		exponent[i] = 0;

				/* work out variable exponents in terms of the variables
				   and degrees of poly_ptr in exponent
				*/
				factor = poly_ptr->l;
				place = pterm_ptr->pl;
				for (i=0; i<poly_ptr->nv;i++)
				{
				    factor /= (2*(poly_ptr->vd[i]+1));
		    		if ((place/factor)%U(2))
						negative_exp = true;
		    		else
						negative_exp = false;

		    		power = place/factor/U(2);
		    		if (negative_exp)
						power *= -1;

		    		exponent[i] = power;

		    		place %= factor;
				}

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize:   pterm @ " << pterm_ptr << " exponents = ";
    for(i=0; i<poly_ptr->nv;i++)
		debug << exponent[i] << " ";
}

				/* now work out the place in terms of the new variable characters
				   and degrees, var_flag tells us if we need to consider the
				   old variable in the amended result
				*/
				place = 0;
				index = 0;
				factor = new_l;
				for (i=0; i<poly_ptr->nv;i++)
				{
				    if (var_flag[i])
		    		{
						factor /= 2 * (new_vd[index++]+1);
						block_num = 2 * abs(exponent[i]);
						if (exponent[i] < 0)
				    		block_num++;
						place += block_num*factor;
		    		}
				}
				pterm_ptr->pl = place;

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << ", new place = " << place << endl;
}

			pterm_ptr = pterm_ptr->next;

	    	} while (pterm_ptr);

	    	/* now correct the polynomial structure */
	    	poly_ptr->nv = strlen(new_vc);
	    	if (poly_ptr->vc)
				delete[] poly_ptr->vc;
	    	if (poly_ptr->vd)
				delete[] poly_ptr->vd;
	    	poly_ptr->vc = new_vc;
	    	poly_ptr->vd = new_vd;
	    	delete[] var_flag;
	    	delete[] exponent;
	    	poly_ptr->l = new_l;
		}
	}

if (polynomial_control::DEBUG & polynomial_control::sanitize)
{
    debug << "polynomial::sanitize: at end of sanitization process " << *poly_ptr;
    dump(debug,*poly_ptr,"polynomial::sanitize:   ");
}

}


/* The function substitute substitutes character c1 for character c2 in poly.
*/

template <typename T, typename V, typename U> void substitute (polynomial<T,V,U>& poly, char c1, char c2)
{
	/* if c1 doesn't exist in poly, or if c2 is already used in poly, do nothing */
	if (!strchr(poly.vc,c1) || strchr(poly.vc,c2))
		return;

if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "substitute: substituting " << c1 << " for " << c2 << " in " << poly <<  endl;
		
	ostringstream oss;
	bool substitute_hold = polynomial_control::SUBSTITUTE_MAPPED_VARIABLES;
	polynomial_control::SUBSTITUTE_MAPPED_VARIABLES = false;
	oss << poly;
	
	string str_poly = oss.str();
	stringSubstitute(str_poly,c1,c2);
	
	map<char,V> poly_map = poly.vm;
	if (poly.vm.count(c1))
	{
		V c1_V = poly_map[c1];
		poly_map.erase(c1);
		poly_map[c2] = c1_V;
	}
	
	poly = polynomial<T,V,U>(str_poly);
	poly.vm = poly_map;
	polynomial_control::SUBSTITUTE_MAPPED_VARIABLES = substitute_hold;
	
/*if (polynomial_control::DEBUG & polynomial_control::general) 
{
	debug << "substitute: polynomial changed to ";
	dump(debug,poly);
}
*/
}


/* The function set_to_one sets the variable ch in poly to one, making the
   appropriate changes in the polynomial structure.
*/
template <typename T, typename V, typename U> void set_to_one (polynomial<T,V,U>& poly, char ch)
{
    int power;
	U block_num;
	U factor;
	U place;
    bool negative_exp;

if (polynomial_control::DEBUG & polynomial_control::general)
    debug << "polynomial::set_to_one: setting variable " << ch << " to 1 in poly " << poly << endl;

    /* if this is the zero polynomial or if there are no variables, or if 
	   ch is not a variable of poly there's nothing to do
    */
    if (!poly.p || poly.nv == 0 || !strchr(poly.vc,ch))
	{
if (polynomial_control::DEBUG & polynomial_control::general)
    debug << "polynomial::set_to_one: nothing to do" << endl;
		return;
	}

	int index = strchr(poly.vc,ch) - poly.vc;
	
if (polynomial_control::DEBUG & polynomial_control::general)
{
    dump(debug, poly);
	debug << endl;
    debug << "polynomial::set_to_one: variable index = " << index << endl;
}

    /* move pterm_ptr to the end of the pterm list */
    pterm<T,U>* pterm_ptr = poly.p;
    while (pterm_ptr->next)
		pterm_ptr = pterm_ptr->next;

    /* set the pterm ptr in poly_ptr to NULL, thereby
       breaking the pterm list from the polynomial structure,
       assign space for the exponents and create the new variable degrees.
       evaluate the new virtual pterm array length.
    */
    poly.p = NULL;
	
    int* new_vd = new int[poly.nv-1];
	
    for (int i=0;i<index;i++)
		new_vd[i] = poly.vd[i];
    for (int i=index+1;i<poly.nv;i++)
		new_vd[i-1] = poly.vd[i];

if (polynomial_control::DEBUG & polynomial_control::general)
{
    debug << "polynomial::set_to_one: new variable degrees ";
	for (int i=0; i<poly.nv-1; i++)
		debug << new_vd[i] << ' ';
	debug << endl;
}
		
    int* exponent = new int[poly.nv];
    U new_l = 1;
	
    for (int i=0;i<poly.nv-1;i++)
		new_l *= 2*(new_vd[i] +1);

if (polynomial_control::DEBUG & polynomial_control::general)
{
    debug << "polynomial::set_to_one: new length = " << new_l << endl;
    debug << "polynomial::set_to_one: working from end of pterm list" << endl;
}

    /* now work back down the list from pterm_ptr, evaluating
       exponents in the original variables from its place, ignoring
       the one at index, then recalcuate the place in terms of the new variable
       list.
    */
    do
    {
		/* First, determine the exponent values of pterm_ptr */
		factor = poly.l;
		place = pterm_ptr->pl;
		int exp_index = 0;
		for (int i=0; i<poly.nv;i++)
		{
		    factor /= (2*(poly.vd[i]+1));
	    	if ((place/factor)%U(2))
				negative_exp = true;
	    	else
				negative_exp = false;

	    	power = place/factor/U(2);
	    	if (negative_exp)
				power *= -1;

	    	/* this is where we ignore the exponent of the indexed variable */
	    	if (i != index)
				exponent[exp_index++] = power;

	    	place %= factor;
		}

if (polynomial_control::DEBUG & polynomial_control::general)
{
    debug << "polynomial::set_to_one: pterm " << pterm_ptr << endl;
    debug << "polynomial::set_to_one:   new exponents ";
	for (int i=0; i<poly.nv-1; i++)
		debug << exponent[i] << ' ';
	debug << endl;
}

		/* now recalculate the place from the new_vd degrees */
		place = 0;
		factor = new_l;
		for (int i=0; i<poly.nv-1;i++)
		{
		    factor /= 2 * (new_vd[i]+1);
	    	block_num = 2 * abs(exponent[i]);
	    	if (exponent[i] < 0)
				block_num++;
	    	place += block_num*factor;
		}
		pterm_ptr->pl = place;

if (polynomial_control::DEBUG & polynomial_control::general)
    debug << "polynomial::set_to_one:   new place =  " << place << endl;

		/* now this changed pterm is ready to be added to the
		   new polynomial list.  Note the += operator will
		   handle the pointers in the pterm and will delete
		   it if it's not needed (because coefficients may be added,
		   note s^2t and st both yield t under set_to_one(s) )
		*/
		pterm<T,U>* changed_pterm = pterm_ptr;
		pterm_ptr = pterm_ptr->prev;
		polynomial<T,V,U>::add_pterm(poly, changed_pterm);

    } while (pterm_ptr);

    /* rearrange the polynomial structure with the correct variables degrees 
	   and length.  If the variable being set to 1 is mapped to a V, then
	   remove the mapping.
    */
	string new_vars;
	for (int i=0 ; i<poly.nv; i++)
	{
		if (i != index)
			new_vars += poly.vc[i];
		
		if (i == index && poly.vm.count(poly.vc[i]) != 0)
			poly.vm.erase(poly.vc[i]);
	}
	
	delete[] poly.vc;
	poly.vc = c_string(new_vars);
    poly.nv -= 1;
    delete[] poly.vd;
    poly.vd = new_vd;
    poly.l = new_l;

if (polynomial_control::DEBUG & polynomial_control::general)
{
    debug << "polynomial::set_to_one: resultant polynomial = " << poly;
	dump (debug, poly);
	debug << endl;
}
    delete[] exponent;
}

/* Laurent_factor returns the smallest polynomial that when multiplied by poly yields 
   a polynomial with no negative degrees 
*/
template <typename T, typename V, typename U> polynomial<T,V,U> Laurent_factor (polynomial<T,V,U>& poly)
{
    int power;
	U block_num;
	U factor;
	U place;
    bool negative_exp;

	int* pexponent; // place exponents
	int* fexponent; // factor exponents
    bool negatives_found = false;

	/* nothing to do if poly is zero */
    if (!poly.p)
		return polynomial<T,V,U>("1");

	/* set up the factor exponents to be zero and declare space for place
	   exponents */
	pexponent = new int[poly.nv];
	fexponent = new int[poly.nv];

	for (int i=0; i< poly.nv; i++)
		fexponent[i] = 0;
	
    /* move to the end of the pterm list and work back, looking for
       negative powers; note that there may not be any!
    */
    pterm<T,U>* pterm_ptr = poly.p;
    while (pterm_ptr->next)
		pterm_ptr = pterm_ptr->next;

    do
    {
		/* work out the exponents of this place and see
		   if any of them are more negative than the factor exponents
		*/
		
		factor = poly.l;
		place = pterm_ptr->pl;
		for (int i=0; i<poly.nv;i++)
		{
    		factor /= (2*(poly.vd[i]+1));
    		if ((place/factor)%2)
			{
				negative_exp = true;
				negatives_found = true;
			}
    		else
				negative_exp = false;

		    power = place/factor/2;
    		if (negative_exp)
				power *= -1;

    		pexponent[i] = power;
    		place %= factor;
		}
		
		/* now see if any of these exponents are less than those
		   stored in fexponent */
		for (int i=0; i< poly.nv; i++)
		{
			if (pexponent[i] < fexponent[i])
				fexponent[i] = pexponent[i];
		}

		pterm_ptr = pterm_ptr->prev;
    } while (pterm_ptr);

	polynomial<T,V,U> pfactor;
	
    if (negatives_found)
    {

if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::Laurent_factor: Laurent_scale factor exponents: ";
	for (int i=0; i< poly.nv; i++)
		debug << fexponent[i] << ' ';
	debug << endl;
}
		
		pfactor.nv = poly.nv;
		pfactor.vc = new char[poly.nv+1];
		strcpy(pfactor.vc,poly.vc);
		pfactor.vd = new int[poly.nv];
		for (int i=0; i<poly.nv; i++)
			pfactor.vd[i] = abs(fexponent[i]);

		pfactor.l = 1;
		for (int i=0; i<poly.nv; i++)	
			pfactor.l *= 2*(abs(fexponent[i])+1);
		
		pfactor.p = new pterm<T,U>;

		/* evaluate the place indicated by fexponent */
		place = 0;
		factor = pfactor.l;
		for (int i=0; i<pfactor.nv;i++)
		{
    		factor /= 2 * (pfactor.vd[i]+1);
    		block_num = 2 * abs(fexponent[i]);
    		place += block_num*factor;
		}
		

		pfactor.p->pl = place;
		pfactor.p->n = T(1);
		pfactor.p->next = NULL;
		pfactor.p->prev = NULL;

if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::Laurent_factor: Polynomial = " << poly << endl;
	debug << "polynomial::Laurent_factor: Laurent scaling factor = " << pfactor << endl;
}

    }
	else
	{
		pfactor = polynomial<T,V,U>("1");
	}
	
	delete[] pexponent;
	delete[] fexponent;
	return pfactor;
}


template <typename T, typename V, typename U> void Laurent_scale (polynomial<T,V,U>& poly)
{
	poly *= Laurent_factor(poly);
	sanitize(&poly);
}

/* lub_Laurent_factor (least upper bound) takes two Laurent factors for polys P1 and P2 and returns 
   the smallest polynomial that is a Laurent factor for both P1 and P2   
*/
template <typename T, typename V, typename U> polynomial<T,V,U> lub_Laurent_factor (polynomial<T,V,U> a, polynomial<T,V,U> b)
{

	U block_num;
	U factor;

//	if ( a == polynomial<T,V,U>("1") )
	if ( a.isone())
		return b;
//	else if ( b == polynomial<T,V,U>("1") )
	else if ( b.isone())
		return a;
	else
	{
		/* work out the variables for the combined factor, the function calls by value so we have 
		   local copies of a and b to work with 
		*/
//		string variables(a.vc);
		string variables = merge_variables(a,b);
	
		sort(variables.begin(), variables.end());

		polynomial<T,V,U> max;
		max.nv = variables.length();
		max.vc = c_string(variables);	
		max.vm = a.vm;  // merge_variables assigns the combined variable map to its first parameter
		
		/* next the variable degrees, note a Laurent factor
		   has no negative degrees */
		max.vd = new int[max.nv];
		for (int i=0; i< a.nv; i++)
			max.vd[i] = 0;
		
		for (int i=0; i< a.nv; i++)
			max.vd[strchr(max.vc,a.vc[i])-max.vc] = a.vd[i];
		
		for (int i=0; i< b.nv; i++)
		{
			int index = strchr(max.vc,b.vc[i])-max.vc;
			if (b.vd[i] > max.vd[index])
				max.vd[index] = b.vd[i];
		}
		
		/* now the length of the virtual pterm list */
		max.l = 1;
		for (int i=0; i<max.nv; i++)	
			max.l *= 2*(max.vd[i]+1);
		
		max.p = new pterm<T,U>;

		/* evaluate the place indicated by the variable degrees */
		max.p->pl = 0;
		factor = max.l;
		for (int i=0; i<max.nv;i++)
		{
    		factor /= 2 * (max.vd[i]+1);
    		block_num = 2 * max.vd[i];
    		max.p->pl += block_num*factor;
		}
		

		max.p->n = T(1);
		max.p->next = NULL;
		max.p->prev = NULL;
	
		return max;	
	}
}


/* Merge the variables from a and b.  There are multiple cases depending upon the overlap of variables

   variable v_b in b does not appear in a
   --------------------------------------
	if v_b mapped in b // case 1   
		if there is a variable v_a in a mapped to the same V. // case 1.1
			if v_a appears in b // case 1.1.1
				substitute v_a in b for a new variable unused in a or b
				substitute v_b in b for v_a 
			else // case 1.1.2
				substitute v_b in b for v_a
		else // case 1.2
			add v_b and its mapping to a
    else // case 2
	  add v_b to the variable characters of a.  

	  
   variable v in b also appears in a
   ---------------------------------

	if v mapped in a // case 3
		if v mapped in b // case 3.1
			if v maps to the same V in both a and b // case 3.1.1
				nothing to do
			else // case 3.1.2
				if there is another variable v' in a that maps to the same V as v does in b // case 3.1.2.1
					if v' appears in b // case 3.1.2.1.1
						substitute v' in b for a new variable unused in a and b
						substitute v for v' in b
					else // case 3.1.2.1.2
						substitute v for v' in b
				else // case 3.1.2.2
					substitute v in b for a new variable unused in a or b 
					add the new variable and its mapping from b to a		   
	   else // case 3.2
			substitute v in b for a new variable unused in a or b
			add the new variable to a
	else // case 4
		if v mapped in b // case 4.1
				if there is another variable v' in a that maps to the same V as v does in b // case 4.1.1
					if v' appears in b // case 4.1.1.1
						substitute v' in b for a new variable unused in a and b
						substitute v for v' in b
					else // case 4.1.1.2
						substitute v for v' in b
				else // case 4.1.2
					substitute v in b for a new variable unused in a or b 
					add the new variable and its mapping from b to a		   
		else // case 4.2
			nothing to do   
*/
template <typename T, typename V, typename U> string merge_variables(polynomial<T,V,U>& a, polynomial<T,V,U>& b)
{
	string variables;
	bool hold = polynomial_control::SUBSTITUTE_MAPPED_VARIABLES;
	
if (polynomial_control::DEBUG & polynomial_control::general) 
{
    polynomial_control::SUBSTITUTE_MAPPED_VARIABLES = false;
	debug << "merge_variables: given polynomials a = " << a << " b = " << b <<  endl;
	debug << "merge_variables: dump of  a:";
	dump(debug,a,"merge_variables:   ");
	debug << "merge_variables: dump of  b:";
	dump(debug,b,"merge_variables:   ");
}
	
	if (a.nv)
		variables += a.vc;

	string combined_variables = variables;
	if (b.nv)
		combined_variables += b.vc;

	/* work with a copy of the variables in b, since substituting variables can
	   re-order the variables stored in the polynomial structure.
	*/
	string b_variables;
	if (b.nv !=0)
		b_variables = string(b.vc);

if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables: b_variables " << b_variables <<  endl;
		
	for (int i=0; i<b.nv; i++)
    {
		char bv = b_variables[i];
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables: processing variable " << bv <<  endl;
	
		/* does the b variable appear in a? */
        if (!a.vc || !strchr(a.vc,bv))
        {					
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   variable " << bv << " does not appear in a" <<  endl;
	
			
			/* is the b variable mapped */
			typename map<char,V>::const_iterator bm_ptr = b.vm.find(bv);
			if (bm_ptr != b.vm.end()) // case 1
			{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 1: variable " << bv << " is mapped in b" <<  endl;
	
				/* is there a variable v_a in a mapped to the same V. */
				typename map<char,V>::const_iterator am_ptr = find_value(a.vm,bm_ptr->second);
				if (am_ptr != a.vm.end()) // case 1.1
				{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 1.1: variable " << am_ptr->first << " in a mapped to the same V" <<  endl;
				
					/* check whether v_a appears in b */
					if (strchr(b.vc,am_ptr->first)) // case 1.1.1					
					{
						char new_variable = next_variable(combined_variables);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 1.1.1: variable " << am_ptr->first << " appears in b, new_variable = " << new_variable <<  endl;
						substitute(b,am_ptr->first,new_variable);
						stringSubstitute(b_variables,am_ptr->first,new_variable);

						substitute(b,bv,am_ptr->first);
						stringSubstitute(b_variables,bv,am_ptr->first);
							
						combined_variables += new_variable;
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b changed to " << b << ", b_variables = " << b_variables << endl;
					}
					else // case 1.1.2
					{
						substitute(b,bv,am_ptr->first);
						stringSubstitute(b_variables,bv,am_ptr->first);
							
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 1.1.2: variable " << am_ptr->first << " does not appear in b, b changed to " << b << ", b_variables = " << b_variables << endl;
					}
				}
				else // case 1.2
				{
					variables += bv;				
					a.vm[bm_ptr->first] = bm_ptr->second;
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 1.2: no variable in a mapped to the same V" <<  endl;
				}
			}		
			else // case 2
			{
				variables += bv;
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   cae 2: variable " << bv << " is not mapped in b" <<  endl;
			}
        }
		else
		{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   variable " << bv << " appears in a" <<  endl;
	
			/* is the variable mapped in a? */
			typename map<char,V>::const_iterator am_ptr = a.vm.find(bv);
			
			/* is the variable mapped in b? */
			typename map<char,V>::const_iterator bm_ptr = b.vm.find(bv);
			
			if (am_ptr != a.vm.end()) // case 3
			{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3: variable " << bv << " is mapped in a to " << am_ptr->second <<  endl;
				if (bm_ptr != b.vm.end()) // case 3.1
				{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1: variable " << bv << " is mapped in b to " << bm_ptr->second <<  endl;
	
					/* check whether v maps to the same V in both a and b */
					if (am_ptr->second != bm_ptr->second) // case 3.1.2
					{
						/*check whether there is another variable v' in a that maps to the same V as v does in b */
						typename map<char,V>::const_iterator am_ptr = find_value(a.vm,bm_ptr->second);
						if (am_ptr != a.vm.end()) // case 3.1.2.1
						{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1.2.1: variable " << am_ptr->first << " in a is mapped to the same V as variable " << bv << " in b" <<  endl;
						
							/* check whether v' appears in b */
							if (strchr(b.vc,am_ptr->first)) // case 3.1.2.1.1				
							{
								char new_variable = next_variable(combined_variables);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1.2.1.1: new_variable for " << am_ptr->first << " in b is " << new_variable <<  endl;
								substitute(b,am_ptr->first,new_variable);
								stringSubstitute(b_variables,am_ptr->first,new_variable);

								substitute(b,bv,am_ptr->first);
								stringSubstitute(b_variables,bv,am_ptr->first);
							
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b changed to " << b << ", b_variables = " << b_variables << endl;
							}
							else // case 3.1.2.1.2
							{
								substitute(b,bv,am_ptr->first);
								stringSubstitute(b_variables,bv,am_ptr->first);
							
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1.2.1.2: variable " << am_ptr->first << " does not appear in b, b changed to " << b << ", b_variables = " << b_variables << endl;
							}
						}												
						else // case 3.1.2.2
						{
							char new_variable = next_variable(combined_variables);					
							V b_map = bm_ptr->second;
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1.2.2: new variable for " << b_map << " in b is " << new_variable << endl;
							substitute(b,bv,new_variable);
							stringSubstitute(b_variables,bv,new_variable);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b updated to " << b << endl;
						
							combined_variables += new_variable;
							variables += new_variable;				
							a.vm[new_variable] = b_map;					
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   a.vm[new_variable] = " << a.vm[new_variable] <<  endl;
						}
					}
					else // case 3.1.1 nothing to do					
					{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.1.1: variable " << bv << " maps to the same V in both a and b, nothing to do" <<  endl;
					}

				}
				else // case 3.2
				{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 3.2: variable " << bv << " is not mapped in b" <<  endl;
					char new_variable = next_variable(combined_variables);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   new variable for " << bv << " in b is " << new_variable << endl;
					substitute(b,bv,new_variable);
					stringSubstitute(b_variables,bv,new_variable);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b updated to " << b << endl;
					combined_variables += new_variable;
					variables += new_variable;				
				}
			}
			else // case 4
			{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 4: variable " << bv << " is not mapped in a" <<  endl;
	
				if (bm_ptr != b.vm.end()) // case 4.1
				{

					typename map<char,V>::const_iterator am_ptr = find_value(a.vm,bm_ptr->second);
					if (am_ptr != a.vm.end()) // case 4.1.1
					{								
						/* check whether v' appears in b */
						if (strchr(b.vc,am_ptr->first)) // case 4.1.1.1
						{
							char new_variable = next_variable(combined_variables);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   cae 4.1.1.1: new_variable for " << am_ptr->first << " in b is " << new_variable <<  endl;
							substitute(b,am_ptr->first,new_variable);
							stringSubstitute(b_variables,am_ptr->first,new_variable);

							substitute(b,bv,am_ptr->first);
							stringSubstitute(b_variables,bv,am_ptr->first);
							
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b changed to " << b << ", b_variables = " << b_variables << endl;
						}
						else // case 4.1.1.2
						{
							substitute(b,bv,am_ptr->first);
							stringSubstitute(b_variables,bv,am_ptr->first);
							
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 4.1.1.2: variable " << am_ptr->first << " does not appear in b, b changed to " << b << ", b_variables = " << b_variables << endl;
						}
					}
					else // case 4.1.2
					{
						char new_variable = next_variable(combined_variables);
						V b_map = bm_ptr->second;
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 4.1.2: new variable for " << b_map << " in b is " << new_variable << endl;
					
						substitute(b,bv,new_variable);
						stringSubstitute(b_variables,bv,new_variable);
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   b updated to " << b << endl;
					
						combined_variables += new_variable;
						variables += new_variable;				
						a.vm[new_variable] = b_map;					
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   a.vm[new_variable] = " << a.vm[new_variable] <<  endl;
					}
				}				
				else // case 4.2, nothing to do
				{
if (polynomial_control::DEBUG & polynomial_control::general) 
	debug << "merge_variables:   case 4.2: variable " << bv << " is not mapped in b, nothing to do" <<  endl;
				}
			}			
		}

//if (polynomial_control::DEBUG & polynomial_control::general) 
//	debug << "merge_variables: finished procesing variable " << bv << " i = " << i << "b.nv = " << b.nv <<  endl;
		
    }
    
if (polynomial_control::DEBUG & polynomial_control::general) 
{
	debug << "merge_variables: produced polynomials a = " << a << " b = " << b <<  endl;
//	debug << "merge_variables: dump of  a:";
//	dump(debug,a,"merge_variables:   ");
//	debug << "merge_variables: dump of  b:";
//	dump(debug,b,"merge_variables:   ");
    polynomial_control::SUBSTITUTE_MAPPED_VARIABLES = hold;
}
	
	return variables;
}

#include<polynomial.int.h>


template<typename T, typename V, typename U> polynomial<T,V,U>::polynomial()
{
	nv = 0;                                               
	vc = NULL;
	vd = NULL;
	l = 0;
	p = NULL;
}

template<typename T, typename V, typename U> polynomial<T,V,U>::polynomial(T t)
{
	nv = 0;                                               
	vc = NULL;
	vd = NULL;
	
	if (t == T(0))
	{
		l=0;
		p = NULL;
	}
	else
	{
		l = 1;
		p = new pterm<T,U>;
		p->n = t;
		p->pl = 0;
		p->next = NULL;
		p->prev = NULL;
	}
}

template<typename T, typename V, typename U> polynomial<T,V,U>::polynomial(char c, V v)
{
	l=4;
	nv = 1;                                               
	vc = new char[2] {c,0};
	vd = new int[1] {1};
	vm[c] = v;
	p = new pterm<T,U>;
	p->n = T(1);
	p->pl = 2;
	p->next = NULL;
	p->prev = NULL;
}

/* copy constructor */
template<typename T, typename V, typename U> polynomial<T,V,U>::polynomial (const polynomial<T,V,U>& poly)
{
    nv = poly.nv;
	if (nv)
	{
		vc = new char[nv+1];
		strcpy(vc, poly.vc);
		vd = new int[nv];
		for (int i = 0; i< nv; i++)
			vd[i] = poly.vd[i];
		
		if (poly.vm.size())
			vm = poly.vm;
	}
	else
	{
		vc = NULL;
		vd = NULL;
	}
	
    l = poly.l;
	
	if (poly.p)
	{
		/* copy the first pterm attached
		   to the polynomial structure
		   pptr points at src pterms
		*/
		pterm<T,U>* pptr = poly.p;	
		pterm<T,U>* pterm_ptr = new pterm<T,U>;
		
		p = pterm_ptr;
		pterm_ptr->next = NULL;
		pterm_ptr->prev = NULL;
		pterm_ptr->n = pptr->n;
		pterm_ptr->pl = pptr->pl;

		while(pptr->next)
		{
		    /* move pptr to the next pterm in poly, create a new
		       pterm at the end of the current list and copy pptr
		       to it
	    	*/
	    	pptr = pptr->next;
	    	pterm_ptr->next = new pterm<T,U>;
	    	pterm_ptr->next->prev = pterm_ptr;
	    	pterm_ptr->next->next = NULL;
	    	pterm_ptr = pterm_ptr->next;
	    	pterm_ptr->n = pptr->n;
	    	pterm_ptr->pl = pptr->pl;
		}
    }
	else
		p = NULL;
}

template<typename T, typename V, typename U> polynomial<T,V,U>::~polynomial()
{
    pterm<T,U>* pterm_ptr;

    if (p)
    {
        /* if the polynomial is non-zero, p is a ptr to the first term,
           move to the end of the list and work backwards, deleting as we go
        */
        pterm_ptr = p;
        while (pterm_ptr->next)
            pterm_ptr = pterm_ptr->next;

        /* now at then end of the list, delete and move backwards */
        do
        {
            /* step back one term */
            pterm_ptr = pterm_ptr->prev;

            /* if pterm_ptr is now NULL we've reached the
               beginning of the list, otherwise delete the pterm
               we've just left
            */
            if (pterm_ptr)
                delete pterm_ptr->next;
        } while (pterm_ptr);

        /* now delete the first pterm indicated by p */
        delete p;
    }

    if (this->vc)
        delete[] vc;
    if (this->vd)
        delete[] vd;
}

/* copy assignment */
template<typename T, typename V, typename U> polynomial<T,V,U> polynomial<T,V,U>::operator = ( const polynomial<T,V,U>& poly)
{
	if (this != &poly)
	{
	    nv = poly.nv;
		if (vc) delete[] vc;
		if (vd) delete[] vd;
		if (nv)
		{
			vc = new char[nv+1];
			strcpy(vc, poly.vc);
			vd = new int[nv];
			for (int i = 0; i< nv; i++)
				vd[i] = poly.vd[i];
				
			if (poly.vm.size())
				vm = poly.vm;
			else
				vm.clear();			

		}
		else
		{
			vc = NULL;
			vd = NULL;
			
			if(vm.size())
				vm.clear();			
		}
	
    	l = poly.l;
		
	    if (p)
	    {
        	/* if the polynomial is non-zero, p is a ptr to the first term,
	           move to the end of the list and work backwards, deleting as we go
	        */
			pterm<T,U>* pterm_ptr = p;
			while (pterm_ptr->next)
		    	pterm_ptr = pterm_ptr->next;

	       	/* now at then end of the list, delete and move backwards */
       		do
       		{
	           	/* step back one term */
           		pterm_ptr = pterm_ptr->prev;

				/* if pterm_ptr is now NULL we've reached the
	               beginning of the list, otherwise delete the pterm
	               we've just left
           		*/
           		if (pterm_ptr)
	               	delete pterm_ptr->next;
	    	} while (pterm_ptr);

       		/* now delete the first pterm indicated by p */
			delete p;
			p = NULL;
    	}
	
		if (poly.p)
		{
			/* copy the first pterm attached
			   to the polynomial structure
			   pptr points at src pterms
			*/
			pterm<T,U>* pptr = poly.p;	
			pterm<T,U>* pterm_ptr = new pterm<T,U>;
		
			p = pterm_ptr;
			pterm_ptr->next = NULL;
			pterm_ptr->prev = NULL;
			pterm_ptr->n = pptr->n;
			pterm_ptr->pl = pptr->pl;

			while(pptr->next)
			{
			    /* move pptr to the next pterm in poly, create a new
			       pterm at the end of the current list and copy pptr
			       to it
		    	*/
	    		pptr = pptr->next;
	    		pterm_ptr->next = new pterm<T,U>;
	    		pterm_ptr->next->prev = pterm_ptr;
	    		pterm_ptr->next->next = NULL;
	    		pterm_ptr = pterm_ptr->next;
	    		pterm_ptr->n = pptr->n;
	    		pterm_ptr->pl = pptr->pl;
			}
    	}
	}
	return *this;
}

template<typename T, typename V, typename U> polynomial<T,V,U>::polynomial(string str)
{
	istringstream ss(str);
	polynomial<T,V,U> loc;
	ss >> loc;

	nv = loc.nv;
	vc = loc.vc;
	loc.vc = NULL;
	vd = loc.vd;
	loc.vd = NULL;
	l = loc.l;
	p = loc.p;
	loc.p = NULL;	
}

/* 
   The operator deals with the case that the variables of a and b may be different and the fact that the 
   variable degrees may be different in a and b, even if the variables overlap.  
   
   In the case of mapped variables, it is the mapped object that determines the variable uniqueness.  Thus,
   the character keys of the two polynomials need to be aligned by the operator in the event that the same 
   mapped object v is used with different character keys by the two polynomials.
*/
template<typename T, typename V, typename U> polynomial<T,V,U> polynomial<T,V,U>::operator += (const polynomial<T,V,U>& p)
{
    char* new_vc;
    int i;
    int new_nv;
    int index;
    int power;
    U block_num;
    int* exponent;
    int* new_vd;

    bool negative_exp;
    pterm<T,U>* pterm_ptr;

    U new_l;
    U factor;
    U place;

//    if ( p == polynomial<T,V,U>(T(0) )
    if ( p.iszero() )
        return *this ;

//    if (*this == T(0))
    if (this->iszero())
	{
		*this = p;
		return *this;
	}
	
	polynomial<T,V,U>& a = *this;
	
	/* take a local copy of b */
	polynomial<T,V,U> b = p;

	string variables = merge_variables(a,b);
	new_nv = variables.length();
	

	sort(variables.begin(), variables.end());
	new_vc = new char[new_nv+1];
	new_vc[variables.copy(new_vc,string::npos)] = 0;


    /* create an array in which to store exponents, note that the
       absolute exponents may change even if the variable characters
       don't.
    */
    exponent = new int[new_nv];

    /* evaluate the new variable degree array, we are adding
       polynomials so we need only take the largest (absolute)
       degree of each variable from each polynomial
    */
    new_vd = new int[new_nv];
    for (i=0; i<new_nv; i++)
        new_vd[i] = 0;

    for (i=0; i<a.nv; i++)
    {
        index = strchr(new_vc, a.vc[i]) - new_vc;
        new_vd[index] = a.vd[i];
    }
    for (i=0; i<b.nv; i++)
    {
        index = strchr(new_vc, b.vc[i]) - new_vc;
        if (b.vd[i] > new_vd[index])
            new_vd[index] = b.vd[i];
    }

    /* calculate the new length of the virtual pterm array */
    new_l = 1;
    for (i=0; i<new_nv; i++)
        new_l *= 2 * (new_vd[i] + 1);

    /* recalculate the place values of a and b in terms of the
       new variable list
    */

    /* a first */
    pterm_ptr = a.p;
    do
    {
        for (i=0; i<new_nv; i++)
            exponent[i] = 0;

        /* work out variable exponents in exponent */
        factor = a.l;
        place = pterm_ptr->pl;
        for (i=0; i<a.nv;i++)
        {
            factor /= (2*(a.vd[i]+1));
            if ((place/factor)%U(2))
                negative_exp = true;
            else
                negative_exp = false;

            power = place/factor/U(2);
            if (negative_exp)
                power *= -1;

            index = strchr(new_vc, a.vc[i]) - new_vc;
            exponent[index] = power;

            place %= factor;
        }

        /* now work out the place in terms of the new varlist */
        place = 0;
        factor = new_l;
        for (i=0; i<new_nv;i++)
        {
            factor /= 2 * (new_vd[i]+1);
            block_num = 2 * abs(exponent[i]);
            if (exponent[i] < 0)
                block_num++;
            place += block_num*factor;
        }
        pterm_ptr->pl = place;

        pterm_ptr = pterm_ptr->next;

    } while (pterm_ptr);

    /* now b */
    pterm_ptr = b.p;
    do
    {
        for (i=0; i<new_nv; i++)
            exponent[i] = 0;

        /* work out variable exponents in exponent */
        factor = b.l;
        place = pterm_ptr->pl;
        for (i=0; i<b.nv;i++)
        {
            factor /= (2*(b.vd[i]+1));
            if ((place/factor)%U(2))
                negative_exp = true;
            else
                negative_exp = false;

            power = place/factor/U(2);
            if (negative_exp)
                power *= -1;

            index = strchr(new_vc, b.vc[i]) - new_vc;
            exponent[index] = power;

            place %= factor;
        }

        /* now work out the place in terms of the new varlist */
        place = 0;
        factor = new_l;
        for (i=0; i<new_nv;i++)
        {
            factor /= 2 * (new_vd[i]+1);
            block_num = 2 * abs(exponent[i]);
            if (exponent[i] < 0)
                block_num++;
            place += block_num*factor;
        }
        pterm_ptr->pl = place;

        pterm_ptr = pterm_ptr->next;

    } while (pterm_ptr);

    /*
       Adjust the polynomial header structure of a to reflect the
       new variables etc.  Note we have already adjusted the 
	   variable map as required.
    */
    a.nv = strlen(new_vc);
    if (a.vc) /* there may or may not be some variables */
        delete[] a.vc;
    a.vc = new_vc;
    if (a.vd)
        delete[] a.vd;
    a.vd = new_vd;
    a.l = new_l;

    /* Now we are ready to add the pterms from b into a.  We start from the
       end and work backwards
    */
    pterm_ptr = b.p;
    while (pterm_ptr->next)
        pterm_ptr = pterm_ptr->next;

    /* add in the pterms until we hit the polynomial structure */
    do
    {
        /* step back one term */
        pterm_ptr = pterm_ptr->prev;

        /* if pterm_ptr is now NULL we've reached the
           beginning of the list, otherwise add in the pterm
           we've just left
        */
        if (pterm_ptr)
			polynomial<T,V,U>::add_pterm(a,pterm_ptr->next);

    } while (pterm_ptr);

    /* now add the first pterm and clear b->p */
	polynomial<T,V,U>::add_pterm(a,b.p);
    b.p = NULL;

    delete[] exponent;

    /* finally sanitize a before returning */
    sanitize (&a);
	
	return a; // = *this
}


template<typename T, typename V, typename U> polynomial<T,V,U> polynomial<T,V,U>::operator -= (const polynomial<T,V,U>& p)
{
	polynomial<T,V,U> loc; 
	loc = p;
	loc *= 	polynomial<T,V,U>(T(-1));
	
	return *this = *this + loc;
}

template<typename T, typename V, typename U>polynomial<T,V,U> polynomial<T,V,U>::operator *= (const polynomial<T,V,U>& p)
{
    int i;
    int index;
    U factor;
    U place;
    int power;
    U block_num;
    int* new_vd = NULL;
    int* exponent = NULL;
    int* aexponent = NULL;

    bool negative_exp;

	polynomial<T,V,U>& a = *this;

	/* take a local copy of b */
	polynomial<T,V,U> b = p;
	
if (polynomial_control::DEBUG & polynomial_control::multiply) 
{
	debug << "polynomial::operator *= : a = " << a << "\n                          b = " << b << endl;
	debug << "polynomial::operator *= : a = " << endl;
	dump(debug,a);
	debug << endl;
	debug << "polynomial::operator *= : b = " << endl;
	dump(debug,b);
	debug << endl;
}
	
    /* if either a or b is the zero poly, return zero polynomial. */
//    if (a == T(0) || b == T(0) )
    if (a.iszero() || b.iszero() )
	{
if (polynomial_control::DEBUG & polynomial_control::multiply) 
	debug << "polynomial::operator *= : one of operands is zero, returning zero" << endl;
		a = polynomial<T,V,U>(T(0));
		return a;
	}

    /* if a is the unit polynomial return a copy of b */
//    if (a == polynomial<T,V,U>(T(1)))
    if (a.isone())
	{
if (polynomial_control::DEBUG & polynomial_control::multiply)
	debug << "polynomial::operator *= : a is \"1\", returning b" << endl;
		a = b;
		return a;
	}
	
    /* if b is the unit polynomial return a copy of a */
//    if ( b == T(1))
    if ( b.isone())
	{
if (polynomial_control::DEBUG & polynomial_control::multiply)
	debug << "polynomial::operator *= : b is \"1\", returning a" << endl;
		return a;
	}
	
    /* So here we need to do a bit of multiplying! First sort out the variable chacters */

	/* build the product in result */
    polynomial<T,V,U> result(a);
    pterm<T,U>* pterm_ptr;
    pterm<T,U>* aptr;
    pterm<T,U>* bptr;
	
	
//  result.nv = a.nv;
//	string variables;
	
	/* this call to merge_variables modifies the variable map in result, so we can build the rest of the 
	   result around it 
	*/
	string variables = merge_variables(result,b);
	result.nv = variables.length();

/*	
	if (a.nv)
		variables += a.vc;
	
    for (i=0; i<b.nv; i++)
    {
		if (variables.find(b.vc[i]) == string::npos)
        {
			variables += b.vc[i];
            result.nv++;
        }
    }
*/
	sort(variables.begin(), variables.end());
	delete[] result.vc;
	result.vc = new char[variables.length()+1];
	result.vc[variables.copy(result.vc,string::npos)] = 0;

if (polynomial_control::DEBUG & polynomial_control::multiply)
	debug << "polynomial::operator *= : new variables = " << result.vc << endl;
	

    /* evaluate the result's variable degree array, we are multiplying
       polynomials so we must add the (absolute) degrees of each variable
       from each polynomial.  We'll tidy up the polynomial later, as this
       process will, repeatedly applied, blow up the length of the virtual
       pterm array.
    */
    if (result.nv)
    {
		delete[] result.vd;
        result.vd = new int[result.nv];
        for (i=0; i<result.nv; i++)
            result.vd[i] = 0;
    }
    else
        result.vd = NULL;

    for (i=0; i<a.nv; i++)
    {
        index = strchr(result.vc, a.vc[i]) - result.vc;
        result.vd[index] = a.vd[i];
    }
    for (i=0; i<b.nv; i++)
    {
        index = strchr(result.vc, b.vc[i]) - result.vc;
        result.vd[index] += b.vd[i];
    }

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
 	debug << "polynomial::operator *= : new variable degrees = ";
	for (int i = 0; i < result.nv; i++)
	{
		debug << result.vd[i] << ' ';
	}
	debug << endl;
}

    /* calculate the new length of the virtual pterm array */
    result.l = 1;
    for (i=0; i<result.nv; i++)
        result.l *= 2 * (result.vd[i] + 1);

if (polynomial_control::DEBUG & polynomial_control::multiply) 
    debug << "polynomial::operator *= : new length = " << result.l << endl;

    /* create an exponent array to hold the exponents of the
       pterms we create, a similar array aexponent that is used
       to optimize the multiplication, and an array new_vd that will
       hold the new maximum variable degrees we calculate.
       Then initialize result.p to NULL.
    */
    if (result.nv)
    {
        exponent = new int[result.nv];
        aexponent = new int[result.nv];
        new_vd = new int[result.nv];
        for (i=0; i<result.nv; i++)
            new_vd[i] = 0;
    }
	
    if (result.p)
    {
        /* if the polynomial is non-zero, p is a ptr to the first term,
           move to the end of the list and work backwards, deleting as we go
        */
        pterm<T,U>* pterm_ptr = result.p;
        while (pterm_ptr->next)
            pterm_ptr = pterm_ptr->next;

        /* now at then end of the list, delete and move backwards */
        do
        {
            /* step back one term */
            pterm_ptr = pterm_ptr->prev;

            /* if pterm_ptr is now NULL we've reached the
               beginning of the list, otherwise delete the pterm
               we've just left
            */
            if (pterm_ptr)
                delete pterm_ptr->next;
        } while (pterm_ptr);

        /* now delete the first pterm indicated by p */
        delete result.p;
    }
	
    result.p = NULL;

    /* now multiply through, creating pterms and adding them to the result as we go */
	int count = 0;
	aptr = a.p;
	while (aptr)
	{
		count++;
		aptr = aptr->next;
	}

	static int cc=0;

    aptr = a.p;
    do
    {
if (polynomial_control::WAIT_INFO && ++cc % polynomial_control::wait_threshold == 0)
{
	switch ((cc/polynomial_control::wait_threshold) % 4)
	{
		case 0: cout << "\r - " << flush; break;
		case 1: cout << "\r \\ " << flush; break;
		case 2: cout << "\r | " << flush; break;
		case 3: cout << "\r / " << flush; break;
	}
}
        /* evaluate the exponents of aptr into aexponent, based
           on the variables in a
        */
        for (i=0; i<result.nv; i++)
            aexponent[i] = 0;

        factor = a.l;
        place = aptr->pl;
        for (i=0; i<a.nv;i++)
        {
if (polynomial_control::DEBUG & polynomial_control::multiply) 
{
    debug << "polynomial::operator *= : place = " << place << endl;
    debug << "polynomial::operator *= : factor = " << factor << endl;
}
            factor /= (2*(a.vd[i]+1));
            if ((place/factor)%U(2))
                negative_exp = true;
            else
                negative_exp = false;

            power = place/factor/U(2);
            if (negative_exp)
                power *= -1;

            index = strchr(result.vc, a.vc[i]) - result.vc;
            aexponent[index] = power;

            place %= factor;
        }

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= : multiplying through by a-term: " << aptr->n;
    for (i=0; i<result.nv;i++)
	{
        if (aexponent[i])
        {
            debug << result.vc[i];

            if (aexponent[i] != 1)
            {
                debug << '^';
                debug << aexponent[i];
            }
        }
	}
    debug << endl;
}

        bptr = b.p;
        do
        {
            /* evaluate the exponents of bptr into exponent, based
               on the variables in b
            */
            for (i=0; i<result.nv; i++)
                exponent[i] = 0;

            factor = b.l;
            place = bptr->pl;
            for (i=0; i<b.nv;i++)
            {
                factor /= (2*(b.vd[i]+1));
                if ((place/factor)%U(2))
                    negative_exp = true;
                else
                    negative_exp = false;

                power = place/factor/U(2);
                if (negative_exp)
                    power *= -1;

                index = strchr(result.vc, b.vc[i]) - result.vc;
                exponent[index] = power;

                place %= factor;
            }

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= :   b-term: " << bptr->n;
    for (i=0; i<result.nv;i++)
	{
        if (exponent[i])
        {
            debug << result.vc[i];

            if (exponent[i] != 1)
            {
                debug << '^';
                debug << exponent[i];
            }
        }
	}
    debug << endl;
}

            /* multiply the variables by adding in aexponent and check
               to see if we have created a new maximum absolute variable
               degree, we use this to tidy up the result later.
            */
            for (i=0; i<result.nv; i++)
            {
                exponent[i]+=aexponent[i];
                if (abs(exponent[i]) > new_vd[i])
                    new_vd[i] = abs(exponent[i]);
            }

            /* create the pterm and assign n, Q and pl.  The pointers will
               be set by the += operator
            */
            pterm_ptr = new pterm<T,U>;
            pterm_ptr->n = aptr->n * bptr->n;
            pterm_ptr->prev = NULL;
            pterm_ptr->next = NULL;

            place = 0;
            factor = result.l;
            for (i=0; i<result.nv;i++)
            {
                factor /= 2 * (result.vd[i]+1);
                block_num = 2 * abs(exponent[i]);
                if (exponent[i] < 0)
                    block_num++;
                place += block_num*factor;
            }
            pterm_ptr->pl = place;

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= :   result: place = " << place << " coeff =  " << pterm_ptr->n;
	debug << " term = ";
    for (i=0; i<result.nv;i++)
	{
        if (exponent[i])
        {
            debug << result.vc[i];

            if (exponent[i] != 1)
            {
                debug << '^';
                debug << exponent[i];
            }
        }
	}
    debug << endl;
 	debug << "polynomial::operator *= : new variable degrees = ";
	for (int i = 0; i < result.nv; i++)
	{
		debug << result.vd[i] << ' ';
	}
    debug << endl;
}
            /* now add the new pterm to result */
            polynomial<T,V,U>::add_pterm(result, pterm_ptr);

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= :   interim result = " << result << endl;
	dump (debug,result);
}

            bptr = bptr->next;
        } while (bptr);
        aptr = aptr->next;
    } while (aptr);

	if (result.nv)
	{
        delete[] exponent;
        delete[] aexponent;
        delete[] new_vd;
	}

    /* Tidy up result before returning it, since the length is probably
       far too high.  We have already noted the correct variable degrees
       as we calculated the pterms but we need to consolidate the
       variables and calculate the new length.
    */
if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= : result prior to sanitizing = " << result << endl;
 	debug << "polynomial::operator *= : variable degrees = ";
	for (int i = 0; i < result.nv; i++)
	{
		debug << result.vd[i] << ' ';
	}
    debug << endl;
}

	sanitize (&result);

if (polynomial_control::DEBUG & polynomial_control::multiply)
{
	debug << "polynomial::operator *= : result after sanitizing = " << result << endl;
 	debug << "polynomial::operator *= : variable degrees = ";
	for (int i = 0; i < result.nv; i++)
	{
		debug << result.vd[i] << ' ';
	}
    debug << endl;
}	
	a = result;
    return a;
}


template<typename T, typename V, typename U> inline polynomial<T,V,U> polynomial<T,V,U>::operator /= (const polynomial& p)
{
	poly_div_res<T,V,U> result = divide_by(*this, p);
	
	return *this = result.q;
}

template<typename T, typename V, typename U> inline polynomial<T,V,U> polynomial<T,V,U>::operator %= (const polynomial& p)
{
	poly_div_res<T,V,U> result = divide_by(*this, p);
	
	return *this = result.r;
}

/* to accommodate mapped variables the equality operator has been re-written to test a difference for the zero polynomial */
template<typename T, typename V, typename U> bool polynomial<T,V,U>::operator == (const polynomial<T,V,U>& a) const
{
    /* first check for the zero poly */
    if (!p && !a.p)
		return true;
	else if (!p || !a.p)
		return false;

    /* next check for the unit poly "1" */
    if (this->isone() && a.isone())
		return true;
	else if (this->isone() || a.isone())
		return false;
		
	if (nv != a.nv)
		return false;
	
	if (vm.size() != a.vm.size())
		return false;
	
	/* Check the variables are the same. Each un-mapped variable in a must appear in this and each 
	   mapped variable in a must have a corresponding variable in this mapped to the same V.  Note
	   that at most one variable in a polynomial may be mapped to given V and we know at this point 
	   of the == operator that we have the same number of variables and the same size of variable maps
	*/
	if (vm.size() == 0)
	{
		for (int i = 0; i < nv; i++)
		{
			if (vc[i] != a.vc[i])
				return false;
		}
	}
	else
	{
		for (int i = 0; i < nv; i++)
		{
			if (a.vm.count(a.vc[i]) == 0)
			{
				if (!strchr(vc,a.vc[i]))
					return false;
			}
			else
			{
				V av = a.get_varmap(a.vc[i]);
				bool found = false;
				typename map<char,V>::const_iterator mptr = vm.begin();
				while (mptr != vm.end())
				{
					if (mptr->second == av)
					{
						found = true;
						break;
					}
					mptr++;
				}
				
				if (!found)
					return false;
			}
		}
	}
	
	/* check variable degrees */
	if (l != a.l)
		return false;
	
	for (int i = 0; i < nv; i++)
	{
		if (vd[i] != a.vd[i])
			return false;
	}
	
	/* the pterms, we know there is at least one in each poly */
	pterm<T,U>* lptr = p;
	pterm<T,U>* aptr = a.p;
	
	/* work along the pterms in this poly and check a has the corresponding term */
	do
	{
		
		if (aptr == NULL || lptr->pl != aptr->pl || lptr->n != aptr->n)
			return false;
		
		lptr = lptr->next;
		aptr = aptr->next;
	} while (lptr);
	
	/* check we're also at the end of a */
	if (aptr)
		return false;

	/* nothing else to check */
	return true;
}



/* This add_pterm function takes a pterm src and adds it to the polynomial.
   If there is no pterm at this place yet, the addition is simply list
   manipulation, otherwise we add the coefficients.

   This function requires that the polynomial has the fields
   nv, vc and vd properly set.  This means that the pterm place
   reflects the correct array of virtual pterms so it will be added
   to dest in the correct place.
*/
template<typename T, typename V, typename U> polynomial<T,V,U> polynomial<T,V,U>::add_pterm (polynomial<T,V,U>& dest, pterm<T,U>* src)
{
    pterm<T,U>*      pterm_ptr;

if (polynomial_control::DEBUG & polynomial_control::add)
{
	debug << "polynomial::add_pterm:  place = " << src->pl << " n = " << src->n << " to polynomial " << endl;
	dump (debug, dest);
}

    if (dest.p == NULL)
    {

if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:\tdestination is zero polynomial, setting src to be head of pterm list" << endl;

        dest.p = src;
        src->next = NULL;
        src->prev = NULL;

if (polynomial_control::DEBUG & polynomial_control::add)
{
	debug << "polynomial::add_pterm:\tdestination dump follows" << endl;
	dump(debug, dest);
}
    }
    else
    {
        pterm_ptr = dest.p;
        while (pterm_ptr->pl < src->pl && pterm_ptr->next)
            pterm_ptr = pterm_ptr->next;

        if (pterm_ptr->pl < src->pl)
        {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:\tadding to end of list" << endl;
	
            /* src needs adding to the end of the list */
            pterm_ptr->next = src;
            src->prev = pterm_ptr;
            src->next = NULL;
        }
        else if (pterm_ptr->pl > src->pl)
        {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:  \tadding before place " << pterm_ptr->pl << endl;

            /* src needs inserting before pterm_ptr, but there may
               or may not be a previous term, since dest may have only
               one term, so we might be at the beginning of the list still.
            */
            if (pterm_ptr->prev)
            {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:  \tprevious term exists" << endl;
                /* there is a previous pterm */
                src->prev = pterm_ptr->prev;
                pterm_ptr->prev->next = src;
                src->next = pterm_ptr;
                pterm_ptr->prev = src;
            }
            else
            {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:  \tadding to the start of the list" << endl;
                /* insert src at the beginning of the list */
                src->prev = NULL;
                dest.p->prev = src;
                src->next = dest.p;
                dest.p = src;
if (polynomial_control::DEBUG & polynomial_control::add)
{
	debug << "polynomial::add_pterm:  \tto give: " << dest << endl;
	dump (debug, dest);
}
            }
        }
        else
        {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:  \tadding to place " << pterm_ptr->pl << endl;

            /* coefficient of src needs adding to pterm_ptr,
               then we can delete src, since we already have a pterm
               at this place.
            */
            pterm_ptr->n += src->n;

            delete src;

            /* check to see if we have reduced this term to zero
               and remove the pterm if we have
            */
            if (pterm_ptr->n == T(0))
            {
if (polynomial_control::DEBUG & polynomial_control::add)
	debug << "polynomial::add_pterm:  \tcreated zero term, removing place " << pterm_ptr->pl << endl;
	
                if (pterm_ptr->prev)
                {
                    pterm_ptr->prev->next = pterm_ptr->next;
                    if (pterm_ptr->next)
                        pterm_ptr->next->prev = pterm_ptr->prev;
                }
                else
                {
                    dest.p = pterm_ptr->next;
                    if (pterm_ptr->next)
                        pterm_ptr->next->prev = NULL;
                }
                delete pterm_ptr;
            }
        }
    }
	return dest;
}

template <typename T, typename V, typename U> bool polynomial<T,V,U>::laurent() const
{
	/* work along the pterms and determine from the place whether
	   the term involves negative exponents
	*/
	pterm<T,U>* pterm_ptr = p;
	
	while (pterm_ptr)
	{
		U factor = l;
		U place = pterm_ptr->pl;
		for (int i=0; i<nv; i++)
		{
    		factor /= (2*(vd[i]+1));
    		if ((place/factor)%U(2))
				return true;
		
			place %= factor;
		}
		pterm_ptr = pterm_ptr->next;
	}
	return false;
}

/* This unit test returns true if the polynomial is +/- 1 or is a
   monomial with coefficient +/- 1, ie, has the form
   +/- x_0^{+/- i_0}...x_n^{+/- i_n}
*/
template <typename T, typename V, typename U> bool polynomial<T,V,U>::isunit() const
{
	const polynomial<T,V,U>& poly = *this;
	
	if (poly.numterms() == 1 && (p->n == T(1) || p->n == T(-1)))
		return true;
	else
		return false;
}


template <typename T, typename V, typename U> bool polynomial<T,V,U>::isone() const
{
	if (nv == 0 && l == 1 && p->pl == U(0) && p->n == T(1))
		return true;
	else
		return false;
}

template <typename T, typename V, typename U> int polynomial<T,V,U>::printlen() const
{
    int i;
    int length = 0;
    U factor;
    U place;
    int power;
    bool negative;
    bool first_term = true;

    pterm<T,U>* pterm_ptr;
	const polynomial<T,V,U>& poly = *this;

    /* check for the zero polynomial */
    if (poly.p == NULL)
    {
        return 1;
    }

    pterm_ptr = poly.p;
    while (pterm_ptr->next)
        pterm_ptr = pterm_ptr->next;

    /* now at then end of the list, output and move backwards */
    do
    {
        /* first the coefficient */
		if (pterm_ptr->n < T(0))
			negative = true;
		else
			negative = false;
		
        if ((!first_term && !negative) || negative )
            length++;

        if (!pterm_ptr->pl || abs(pterm_ptr->n) != T(1) )
			length += num_len(abs(pterm_ptr->n));

        /* now the variables */
        factor = poly.l;
        place = pterm_ptr->pl;
        for (i=0; i<poly.nv;i++)
        {
            factor /= (2*(poly.vd[i]+1));
            if ((place/factor)%U(2))
                negative = true;
            else
                negative = false;

            power = place/factor/U(2);
            if (negative)
                power *= -1;

            if (power)
            {
				if (poly.vm.count(poly.vc[i]) != 0 && polynomial_control::SUBSTITUTE_MAPPED_VARIABLES)
				{
					ostringstream oss;					
					oss << poly.get_varmap(poly.vc[i]);
					length += oss.str().length();
				}
				else
				{
					length++;
				}

                if (power != 1)
                {
                    length++;
                    length += num_len(power);
                }
            }

            place %= factor;
        }

        /* step back one term */
        pterm_ptr = pterm_ptr->prev;
        first_term = false;
    } while (pterm_ptr);

    return length;
}

template <typename T, typename V, typename U> int polynomial<T,V,U>::numterms() const
{
	if (p == NULL)
		return 0;
	
	int terms = 1;
	pterm<T,U>* pterm_ptr = p;
	
	while (pterm_ptr->next != NULL)
	{
		terms++;
		pterm_ptr = pterm_ptr->next;
	}
	return terms;
}


template <typename T, typename V, typename U> void polynomial<T,V,U>::set_varmap(char c, V v)
{
	if (nv && strchr(vc,c))
	{
		/* remove any existing mapping to v */
		if (vm.size() != 0)
		{
			typename map<char,V>::const_iterator mptr = vm.begin();
			bool found=false;
			while (mptr != vm.end())
			{
				if (mptr->second == v)
				{
					found = true;
					break;
				}
				mptr++;
			}
			if (found)
				vm.erase(mptr);
		}
		
		vm[c]=v; // set variable mapping
	}
}


/* min_degrees evaluates the smallest variable degrees common to all
   terms of a polynomial 
*/
template <typename T, typename V, typename U> vector<int> polynomial<T,V,U>::min_degrees() const
{
	if (nv == 0)
		return vector<int>();
	
	int* min_exponent = new int[nv];
	U factor;
	U place;
	pterm<T,U>* pterm_ptr = p;

	for (int i = 0; i< nv; i++)
		min_exponent[i] = vd[i];
		
if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::min_degrees: *this" << endl;
	dump (debug, *this);
}

	/* work out the exponents of each term and compare them with min_exponent */
	do
	{
	    factor = l;
	    place = pterm_ptr->pl;
		
if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::min_degrees: pterm_ptr: " << pterm_ptr << " place = " << place << " factor = " << factor << endl;
}
	    for (int i=0; i<nv;i++)
	    {
        	factor /= (2*(vd[i]+1));

if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "\ti= " << i << " factor = " << factor << " place/factor = " << place/factor << flush;
}

        	if ((place/factor)%U(2))
			{
				cout << "\n\nError! min_degrees not supported for Laurent polynomials" << endl;
breakpoint();				
				exit(0);
			}

        	int power = place/factor/U(2);
			
if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::min_degrees:  power = " << power << endl;
}
		
			if (power < min_exponent[i])
        	min_exponent[i] = power;
        	place %= factor;
    	}
		pterm_ptr = pterm_ptr->next;
	} while (pterm_ptr != NULL);
	
if (polynomial_control::DEBUG & polynomial_control::general)
{
	debug << "polynomial::min_degrees: min_degrees ";
	for (int i=0; i< nv; i++)
		debug << min_exponent[i] << ' ';
	debug << " calculated for " << *this << endl;
}

	vector<int> degrees(nv);
	for (unsigned int i=0; i< (unsigned int)nv; i++)
		degrees[i] = min_exponent[i];

	delete[] min_exponent;
	return degrees;
}


